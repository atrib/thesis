\chapter{Introduction}
\epigraph{Testing can only prove the presence of idiots, not their absence. Software is written---for the most part---by idiots.}%
         {\textit{Aristotle}}


% Context, computers are running ever increasing code bases, which are impossible to definitively verify
% and which are getting executed in shared environments all the time.
% Computer systems and computing environments have significantly evolved over time.
% \begin{itemize}
%   \item The complexity and scale of computing systems has increased exponentially for decades. 
%   \item The scale of modern systems allows, and also relies on, a large degree of sharing. 
%   \item The degree of code sharing has changed dramatically, 
%         from 
%         code written by individual tech-savvy developers and run on their personal machines
%         to 
%         code fully written and distributed by corporations and run by users on their personal machines
%         to
%         code written and distributed by a large variety of sources, and implicitly run in shared environments
%         by even unwitting users on personal machines.
%   \item Large amount of shared code cannot be vetted even by large corporations (e.g., popular libraries)
%   \item Shared code gets distributed by avenues with low checks or measures (e.g., package managers like crate, npm)
%   \item Browsers fetch and execute code on-demand from an infinitely varying set of sources.
%   \item Consequently, modern systems include a wider range of trust relationships compared to traditional systems.
% \end{itemize}
The computing landscape is one of rapid expansion and evolution.
Modern computing systems inherit many of the abstractions and interfaces
developed at the inception of personal computing and mainframe servers,
but face a very different computing environment.
First, the complexity and scale of computing systems have increased 
exponentially over the decades, far outscaling the ability for developers to 
exhaustively test and verify their systems, leading to an abundance of bugs.
Second, this scaling in complexity relies on, and also enables, pervasive code
sharing.
A web browser (e.g., Firefox) along with the underlying operating 
system (e.g., Linux) accounts for hundreds of millions of lines of code
including
\begin{inparaenum}
      \item mainline kernel code written by a globally distributed consortium,
      \item numerous device drivers written by the respective hardware 
            vendors,
      \item shared libraries and modules developed independently and 
            written using a plethora of different languages,
      \item code from websites, often including other embedded pages,
            written by respective developers.
\end{inparaenum}
Modern systems need to include the threat of bugs in shared code
compromising their security in the their threat model, and implement
necessary mitigations.
For example, a developer of web code must consider the threat that any of the
thousands of JavaScript packages their code depends on might be malicious,
currently or in the future.
% See this example:
% https://therecord.media/malware-found-in-npm-package-with-millions-of-weekly-downloads


% The core problem: mismatch between interface design and modern computing trust relations
% Modern systems are implemented on legacy interfaces, incurring security or performance limitations.
% \begin{itemize}
%   \item modern systems continue to rely extensively on legacy interfaces. 
%   Examples  of these interfaces include the ISA interface and OS system call interface, both of which largely resemble systems from 20-40 years back.
%   For example, the virtual memory definition of traditional ISAs focus on isolating different virtual address spaces from each other, whereas modern systems mix code from various untrusted sources within the same address space.
%   \item Interfaces might lack the expressivity to express modern trust relations (virtual memory)
%   \item Interfaces might include implicit assumptions, including ones not noticed by the developers of the interface, which may be wilfully or unknowingly violated by malicious or buggy code.
% \end{itemize}
% Problems with two specific interfaces are tackled by this thesis.
% \begin{itemize}
%   \item The OS interface to userspace lacks protection against concurrent modification by userspace. 
%         A contributing factor to this problem could be the relative absence of concurrency, and absolute 
%         lack of parallelism when modern operating systems were conceived.
%   \item The ISA interface for virtual memory contains a single permission for any address, for all code
%         executing within that address space.
%         This design was sufficient when programs trusted all of their code, moreso since most computers 
%         ran code entirely designed and written by one corporation.
%         The relative infancy of the internet meant very limited code sharing, and only among developers when
%         at all.
% \end{itemize}
While computing systems have evolved significantly, interfaces between many 
parts of this system remain entrenched in antiquity.
The designs of these interfaces reflect the requirements and threat landscape
of their respective design periods, but fail to adequately address modern
needs.
One consequence is that interfaces might not adequately mitigate threats
that have arisen or worsened \emph{after} the design of the interface.
For example, the kernel system call has always considered the threat
of attacks from untrusted userspace and system calls typically check the 
validity of arguments passed from userspace.
Meanwhile, computing has evolved to support increased concurrency and true 
parallelism, with the rise in popularity of multicore CPUs and multi-threaded 
programs.
For system call arguments stored in user memory and passed by reference,
this evolution has opened the gates for data races if the user program
modifies the arguments from a second thread while the kernel executes
a system call from one thread.
A second consequence is that interfaces might not provide the correct
abstractions to efficiently support program design that reflects
modern trust relations.
For example, the dominant abstraction for isolation within userspace code
is a process, and different applications typically execute in different 
processes to isolate applications from bugs in other applications.
Isolation using processes is well suited to the historical state of software
development where software vendors wrote their own applications with limited
code sharing between vendors.
Processes isolated code for one application, from one software vendor,
from other applications, from other software vendors or for another user.
With more code within applications originating from third-party developers
and less trust of code run within a single process, intra-process isolation
has become crucial.
Security-critical programs, like browsers, microservices and microkernel
operating systems (OSs), refactored to enforce intra-application isolation 
using processes are limited by the high overheads of this abstraction, and 
only support coarse-grained isolation to provide acceptable performance.


% Prior work around fixing abstractions or introducing new ones
% Recent work has started tackling this problem at various levels. 
% \begin{itemize}
%   \item Papers have tried to remove this implicit assumption from the kernel by attempting to find and 
%         refactor code vulnerable to userspace TOCTTOU, using methods based on static and dynamic analysis.
%         Limitations of existing works includes:
%         - protection only against known bugs, 
%         - detection of subset of bugs triggered by dybnamic analysis,
%         - other shortcomings described in the paper.
%   \item Mechanisms (research and production) have tried to introduce additional access control within an
%         address space to isolate parts of a program which do not trust each other.
%         However, these mechanisms continue to trade-off performance and security guarantees. 
%         - Some existing mechanisms offer a thin additional layer of security for very little overhead.
%         - Others provide more comprehensive protection, but at high cost.
%         A common contributing factor to higher costs is a reliance on more traditional abstractions.
%         Particularly, the OS is included in the TCB and tasked with implementing switching between
%         protection domains or compartments, assuring security at high cost.
% \end{itemize}
Continuing industrial and academic efforts have proposed various 
improvements to improve the kernel-user boundary and add isolation within
a process.
The security of operating systems is an area of active research, and many
methodologies have been proposed to fix the issue of data races at the system
call interface, primarily focussing on finding and fixing instances of such
bugs.
One class of proposals~\cite{dftracker, deadline, dftinker} leverage static
analysis to search the OS codebases for specific vulnerable patterns.
Alternative proposals~\cite{schwartzDECAF,jurczyk2013bochspwn,wilhelm2016xenpwn}
leverage dynamic analysis to detect instances of data races at runtime.
Finally, DECAF~\cite{schwartzDECAF} repurposes a CPU-specific feature
intended for accelerating database transactions to instead mitigate such
bugs.
Bug finding techniques, however, are insufficient --- they can only fix
bugs found, and both static and dynamic analysis are incomplete.
The significant churn in code further complicates the challenge, as every
change potentially introduces a new such bug.
DECAF's mitigation is also incomplete, since the protection depends on
a vendor-specific feature, which has since also been deprecated on newer
processors.
The system call interface requires a more principled and reliant
mitigation against data race attacks.
Similarly, while researchers and processor vendors continue to propose 
mechanisms for finer-grained isolation within a process' address space, 
these mechanisms vary in their design goals, and do not adequately
support widespread adoption.
Mechanisms which prioritize backward compatibility with existing 
systems~\cite{LittonVE0BD16, HsuHEP16, HedayatiGJCSSM19Hodor, LeeSK18, DuHXZC19XPC}
introduce the security benefits of intra-address space isolation
but continue to suffer the consequences of other legacy design choices, 
such as expensive supervisor-mediated context switches.
Some mechanisms~\cite{ParkLXMK19, HedayatiGJCSSM19Hodor} trade off 
performance for security, either providing weaker security than processes
to provide better performance or making restrictive assumptions on
use case.


% Insights: Problems with abstractions can be fixed. 
% Fixes might require principled changes to the interfaces, as either mitigations which preserve the
% interface but allow additional checks to be implemented, or as a redesign of the entire interface.
% In this thesis, we solve the two interfaces by:
% \begin{itemize}
%   \item We recognize that
%           TOCTTOU comes in the insight that devs make an implicit assummption.
%         System calls implicitly assume that their view of accessed user memory does not change
%         during the system call's lifetime. 
%         The kernel uses a well-defined software interface to access user memory. 
%         The clean separation of the access interface allow additional checks to assure that 
%         the implicit invariant is upheld.
%   \item The hardware is part of the TCB, and can be tasked with managing permissions for different
%         compartments, read from one two-D table.
% \end{itemize}
Security guarantees should inform the design of interfaces --- either by 
extending or redesigning interfaces.
% 
At the kernel-user interface, we see that data races require the kernel
to access the same argument in user memory at least twice, which
allows the user to modify the data in the meantime.
In fact, such bugs which are generally called double-fetch bugs commonly 
manifest from the same usage pattern.
The kernel first loads arguments once to check their validity, then
loads them at a later time in order to use them.
This pattern earns these bugs the often-used moniker of 
Time-of-Check-to-Time-of-Use (TOCTTOU) bugs.
A double-fetch bug manifests from an implicit assumption by the developer
that the fetched data is the same, which is violated by the attacking
user.
OS kernels generally use a softare interface to access user memory, to manage
protections like Supervisor Memory Access Prevention (SMAP), and we can
extend this interface with a secure invariant.
% 
Within userspace, however, the requirements for isolation have changed 
drastically: from isolating per-user processes which occupy millisecond-scale
scheduling slots to finer grained module or library-level isolation, which
demands sub-microsecond operations (for example, compartment switching).
An userspace process needs to be further divided into isolated compartments
which can communicate along well-defined APIs.
Software OS mechanisms are expensive --- even IPC-optimized supervisors
on commodity hardware achieve millisecond-scale compartment switches at
best.
We notice that the traditional trusted-computing base includes the hardware
alongside the supervisor.
Hence, we can securely move some operations (access control, inter-compartment
control and data flow) from the supervisor to the hardware improving 
performance while maintaining the same security guarantees.
Improvements and trends in microarchitectural design, such as the trend towards
VMA-based access control in the core's translation-lookaside buffer 
(TLB)~\cite{0003BOBFP21midgard} greatly assist in this transition.


% Solution:
We solve the security issues at the interfaces by:
\begin{itemize}
  \item Fixing the interface implementation. 
        We introduce a mitigation at the kernel-user interface tasked with maintaining
        the implicit assumption.
        We solve the kernel TOCTTOU problem by maintaining a strong invariant:
        all reads from user memory return the same value throughout the lifetime of the system call.
        We implement multi-version concurrency through the user-memory read method (read from user).
  \item Enriching the interface implementation to enable developers to express their
        trust model and relationships. 
        We solve the compartmentalization problem by defining a new architectural virtual memory
        interface, where the hardware isolates compartments based on permissions stored in a 
        two-dimensional table, and tracking per-core executing compartment, along with 
        userspace instructions for accelerating compartmentalization operations.
\end{itemize}
\section{Kernel TOCTTOU Protection Overview}

% Itemize
\begin{itemize}
  \item The design of many modern operating system kernels heavily draw inspiration from UNIX.
        These kernels have progressively developed to incorporate modern features and modern
        security models.
  \item System call interfaces were designed in the era of uniprocessors.
  \item Userspace was suspended during kernel syscall processing.
  \item Multi-threading was not commonplace.
\end{itemize}

Short introduction on the Kernel TOCTOTU problem.
\begin{itemize}
      \item User space uses system calls to request operating system kernel operations
      \item System call arguments are passed through registers and through memory
      \item Kernel reads userspace memory, sometimes in separate accesses for checks
            and use (TOCTTOU)
      \item Concurrent or parallel userspace threads sharing the address space can 
            modify the arguments in memory
      \item Earlier kernel code implicitly assumes that userspace is paused while
            syscall executes. This assumption would be almost certain in less
            adversarial environments, and on single-core computers.
      \item Today, the kernel works with different threat assumptions, however, 
            vulnerable code still remains, despite efforts to eliminate TOCTTOU.
            Partly due to implicit assumptions
            by developers, sometimes due to legacy code.
\end{itemize}

We recognize this assumption as a core assumption and develop a mitigation
to enforce this implicit assumption.
Our mitigation is based on a strong statement as an invariant. 
Midas enforces that all accesses to user memory from kernel code returns
the same value during the system call's lifetime.
Midas maintains this invariant by maintaining multiple concurrent versions
of user pages when they are accessed by the kernel, in order to keep one
current copy available for writes by userspace and the kernel, 
with zero or more read-only copies available for reads by executing system calls.
Copies are created on demand, only when a page locked by a system call sees
a modifying write.

We eliminate TOCTTOU in a systematic solution which will:
\begin{itemize}
      \item Protect current (potentially unknown) TOCTTOU bugs in the kernel,
      \item Protect vulnerable kernel modules or ebpf code developed 
            by third parties,
      \item Protect older systems with minor updates.
\end{itemize}

Our solution leverages the software user memory access routine, and
hardware-enforced page table permissions.

\section{Intra-address Space Compartmentalization Overview}

SecureCells introduces a novel mechanism for intra-address space compartmentalization,
aiming to provide secure, performant and flexible support for isolation between
fine-grained compartments between a program. 

SecureCells tackles the challenge of tailoring existing abstractions to keep up to date
with modern threat models.
Over the years, code sharing has become increasingly commonplace, essentially
removing duplication of programmer effort, and allowing consumers to access
vastly varying computing experiences.
These experiences are enabled by:
\begin{itemize}
  \item Libraries (open-source or binary-only) distributed and shared widely across
        programs, implementing widely-used operations like cryptography or
        parsing common file formats. Often such code is available through package 
        managers like apt or npm as source code or binary blobs. 
        The intricate web of dependencies between libraries often results in
        additional code being included.
  \item Extensible frameworks like the linux kernel allow functionality to be added
        on-demand, through the use of external code (such as kernel drivers or eBPF
        payloads),
  \item On-demand code being distributed to power interactive experiences on the web.
        Websites are powered by vast code-bases of JavaScript, PHP and Wasm which are
        dynamically loaded from servers and executed in sandboxes.
\end{itemize}
In all of these cases, an address space runs code written by a variety of different
sources, with different levels of trust and testing, and with a significant code 
churn.

SecureCells proposes a novel architecture, comprising
\begin{itemize}
  \item Compartmentalized virtual memory, with the hardware MMU responsible for
        enforcing access control to memory across isolated compartments, based on 
        per-core compartment identifiers and permissions stored on an in-memory
        two dimensional table storing per-compartment, per-virtual memory permissions,
  \item Userspace instructions, securely accelerating common compartmentalization 
        operations implemented as hardware execution units, microcode or firmware,
  \item Software operations, flexibly adding the remaining functionality with the
        same security or performance guarantees as hardware.
\end{itemize}
% \section{Thesis goals}

% This thesis addresses the challenge of securing systems across an evolving
% computing landscape, particularly at interfaces.
% Interfaces within a system are particularly susceptible to security or
% performance shortcomings.
% Different threat models among components, or a misunderstanding of the
% security guarantees of other components, can compromise an entire system.
% Mismatched abstractions also impose performance overheads, as developers
% adapt their code accordingly.




\section{Thesis statement}

The design of interfaces between layers of the computing system stack decisively influence the 
security and performance characteristics of the system --- 
strong, well-defined guarantees at the interfaces allow developers to build well-protected 
high-performance systems.
This thesis improves the user-kernel interface by elevating an implicit assumption to 
an explicit guarantee, preventing a class of data-race driven attacks.
This thesis also proposes an architectural interface for compartmentalized virtual memory
with strong isolation guarantees, by design, at high performance.

\section{Thesis contributions}

This thesis contributes the design and implementations of modern
security- and performance-critical interfaces to support 
current and future computing systems.
Midas redesigns the userspace memory access interface to provide
strong mitigations against data race attacks.
SecureCells introduces compartmentalization to the architectural
virtual memory interface.

Midas' design is based on the following insights:
\begin{itemize}
  \item Modern OS kernels rely on softare interfaces to access
        user memory, disabling and re-enabling related
        protection measures like SMAP.
  \item Non-adversarial userspace software will not modify
        system call arguments passed by reference, as they
        rely on the system call completing successfully.
        Data races are, therefore, not the common case, and
        the protection mechanism should be designed for better
        performance when not under attack
  \item Duplication of userspace memory is expensive, requiring
        the corresponding memory allocation and expensive
        metadata tracking.
  \item The kernel does not need to duplicate userspace memory
        except in the case of concurrent updates. In the common
        case, duplication should be avoided.
  \item MMU-based permission checks are ubiquitious in modern
        architectures, allowing the hardware to efficiently
        enforce read-only access to memory regions, and
        notify the OS on violations.
\end{itemize}
This thesis contributes a design for system-call protection for Linux
based on these insights.

In this thesis, we also describe the design and implementation of
SecureCells, our novel architecture for intra-address space
compartmentalization.
We
\begin{itemize}
  \item Explore the requirements for compartmentalization, and
        categorize these requirements under performance, security
        and flexibility umbrellas,
  \item Present the design of three pillars of SecureCells: 
        hardware access control, unprivileged userspace instructions
        and softare operations.
\end{itemize}


SecureCells contributions
Enumeration of the requirements for compartmentalized software.

\section{Thesis Organization}

This section describes such and such.

That section describes such and such.

\subsection{Bibliographic Notes}
This thesis was supervised by my advisors, Prof. Mathias Payer and Prof. Babak Falsafi.
Portions of the thesis describe projects conducted in collaboration with academic and
industrial peers, namely Uros Tesic, Florian Hofhammer, Yuanlong Li, Siddharth Gupta, 
and Andres Sanchez.
The design, implementation and evaluation of SecureCells, described in 
\autoref{ch:seccells}, was published as a conference paper in the 
\emph{Proceedings of the $44^{th}$ IEEE Symposium on Security and Privacy, SP 2023}.
The investigation of TOCTTOU protection, described in \autoref{ch:midas},
was published in the
\emph{Proceedings of the 31st USENIX Security Symposium} in 2022.

