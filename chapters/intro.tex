%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Customary 5-part intro explaining:
%%%%%%% Context, problem, prior work, insight and solution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Context, computers are running ever increasing code bases, which are impossible to definitively verify
% and which are getting executed in shared environments all the time.
% Computer systems and computing environments have significantly evolved over time.
% \begin{itemize}
%   \item The complexity and scale of computing systems has increased exponentially for decades. 
%   \item The scale of modern systems allows, and also relies on, a large degree of sharing. 
%   \item The degree of code sharing has changed dramatically, 
%         from 
%         code written by individual tech-savvy developers and run on their personal machines
%         to 
%         code fully written and distributed by corporations and run by users on their personal machines
%         to
%         code written and distributed by a large variety of sources, and implicitly run in shared environments
%         by even unwitting users on personal machines.
%   \item Large amount of shared code cannot be vetted even by large corporations (e.g., popular libraries)
%   \item Shared code gets distributed by avenues with low checks or measures (e.g., package managers like crate, npm)
%   \item Browsers fetch and execute code on-demand from an infinitely varying set of sources.
%   \item Consequently, modern systems include a wider range of trust relationships compared to traditional systems.
% \end{itemize}
The computing landscape is one of rapidly growing software and hardware
complexity.
Modern computing systems inherit many of the abstractions and interfaces
developed at the inception of personal computing and mainframe servers,
but face a very different computing environment.
First, the complexity and scale of computing systems have increased 
exponentially over the decades, far outscaling the ability for developers to 
exhaustively test and verify their systems, leading to an abundance of bugs.
Popular software runs hundreds of millions of lines of source code, with
millions of lines worth of changes every year.
Transistor counts for processors have roughly followed Moore's law for
near 50 years, and a modern Apple M2 chip has more than a $10^{11}$
transistors compared to the 68,000 transistors of the Motorola 68k processor
from 1979.
Second, this scaling in complexity relies on, and also enables, pervasive code
sharing.
A web browser (e.g., Firefox) along with the underlying operating 
system (e.g., Linux) accounts for hundreds of millions of lines of code
including
\begin{inparaenum}
      % this point is meant to demonstrate the somewhat lack of formal structure
      % in Linux development. 
      % Individual devs are allowed to contribute their own improvements, 
      % alongside improvements planned centrally by Linus, maintainers and co.
      \item mainline kernel code written by a informal melange of developers
            distributed across the globe and varying 
            industrial/academic/governmental/individual affiliation,
      % fragmentation of sources/developers
      \item numerous device drivers written by the respective hardware 
            vendors,
      % absolute fragmentation of library development. popular libs developed
      % independently, and were incrementally adopted based on popularity
      \item shared libraries and modules developed independently and 
            written using a plethora of different languages,
      % again, fragmentation of sources, but particularly on lack of trust
      \item code from websites, often including other embedded pages,
            written by respective developers.
\end{inparaenum}
Modern systems need to include the threat of bugs in shared code
compromising their security in the their threat model, and implement
necessary mitigations.
For example, a developer of web code must consider the threat that any of the
thousands of JavaScript packages their code depends on might be malicious,
currently or in the future.
% See this example:
% https://therecord.media/malware-found-in-npm-package-with-millions-of-weekly-downloads


% The core problem: mismatch between interface design and modern computing trust relations
% Modern systems are implemented on legacy interfaces, incurring security or performance limitations.
% \begin{itemize}
%   \item modern systems continue to rely extensively on legacy interfaces. 
%   Examples  of these interfaces include the ISA interface and OS system call interface, both of which largely resemble systems from 20-40 years back.
%   For example, the virtual memory definition of traditional ISAs focus on isolating different virtual address spaces from each other, whereas modern systems mix code from various untrusted sources within the same address space.
%   \item Interfaces might lack the expressivity to express modern trust relations (virtual memory)
%   \item Interfaces might include implicit assumptions, including ones not noticed by the developers of the interface, which may be wilfully or unknowingly violated by malicious or buggy code.
% \end{itemize}
% Problems with two specific interfaces are tackled by this thesis.
% \begin{itemize}
%   \item The OS interface to userspace lacks protection against concurrent modification by userspace. 
%         A contributing factor to this problem could be the relative absence of concurrency, and absolute 
%         lack of parallelism when modern operating systems were conceived.
%   \item The ISA interface for virtual memory contains a single permission for any address, for all code
%         executing within that address space.
%         This design was sufficient when programs trusted all of their code, moreso since most computers 
%         ran code entirely designed and written by one corporation.
%         The relative infancy of the internet meant very limited code sharing, and only among developers when
%         at all.
% \end{itemize}
While computing systems have evolved significantly, interfaces between many 
parts of this system remain entrenched in antiquity.
The designs of these interfaces reflect the requirements and threat landscape
of their respective design periods, but fail to adequately address modern
needs.
One consequence is that interfaces might not adequately mitigate threats
that have arisen or worsened \emph{after} the design of the interface.
For example, the kernel system call has always considered the threat
of attacks from untrusted userspace and system calls typically check the 
validity of arguments passed from userspace.
Meanwhile, computing has evolved to support increased concurrency and true 
parallelism, with the rise in popularity of multicore CPUs and multi-threaded 
programs.
For system call arguments stored in user memory and passed by reference,
this evolution has enabled data races if the user program
modifies the arguments from a second thread while the kernel executes
a system call from one thread.
A second consequence is that interfaces might not provide the correct
abstractions to efficiently support program design that reflects
modern trust relations.
For example, the dominant abstraction for isolation within userspace code
is a process, and different applications typically execute in different 
processes to isolate applications from bugs in other applications.
Isolation using processes is well suited to the historical state of software
development where software vendors wrote their own applications with limited
code sharing between vendors.
Processes isolated code for one application, from one software vendor,
from other applications, from other software vendors or for another user.
With more code within applications originating from third-party developers
and less trust of code run within a single process, intra-process isolation
has become crucial.
Security-critical programs, like browsers, microservices and microkernel
operating systems (OSs), refactored to enforce intra-application isolation 
using processes are limited by the high overheads of this abstraction, and 
only support coarse-grained isolation to provide acceptable performance.


% Prior work around fixing abstractions or introducing new ones
% Recent work has started tackling this problem at various levels. 
% \begin{itemize}
%   \item Papers have tried to remove this implicit assumption from the kernel by attempting to find and 
%         refactor code vulnerable to userspace TOCTTOU, using methods based on static and dynamic analysis.
%         Limitations of existing works includes:
%         - protection only against known bugs, 
%         - detection of subset of bugs triggered by dybnamic analysis,
%         - other shortcomings described in the paper.
%   \item Mechanisms (research and production) have tried to introduce additional access control within an
%         address space to isolate parts of a program which do not trust each other.
%         However, these mechanisms continue to trade-off performance and security guarantees. 
%         - Some existing mechanisms offer a thin additional layer of security for very little overhead.
%         - Others provide more comprehensive protection, but at high cost.
%         A common contributing factor to higher costs is a reliance on more traditional abstractions.
%         Particularly, the OS is included in the TCB and tasked with implementing switching between
%         protection domains or compartments, assuring security at high cost.
% \end{itemize}
Continuing industrial and academic efforts have proposed various 
improvements to improve the kernel-user boundary and add isolation within
a process.
The security of operating systems is an area of active research, and many
methodologies have been proposed to fix the issue of data races at the system
call interface, primarily focussing on finding and fixing instances of such
bugs.
One class of proposals leverage static analysis to search the 
OS codebases for specific vulnerable patterns.
DFTinker~\cite{dftinker} and Wang et. al.~\cite{wang2017double} use
pattern matching derived from known double fetch bugs.
DFTracker~\cite{wang2019dftracker} and Deadline~\cite{deadline} further
generalize the search using symbolic execution.
Alternative proposals
leverage dynamic analysis to detect instances of data races at runtime
by tracking kernel memory accesses running various common 
workloads (for e.g., booting up, running a browser, playing multimedia).
Bochspwn~\cite{jurczyk2013bochspwn} runs the target OS in an emulator, 
whereas DECAF~\cite{schwartzDECAF} and Xenpwn~\cite{wilhelm2016xenpwn}
run on native hardware and rely on hardware tracing functionality.
Eliminating the found data races through bug fixes in source code allows the
kernel to present a more secure interface, though the invulnerability to 
data races remains an informal assumption rather than a guarantee.
% schwartsDECAF has decaf - detection, dropit - mitigation.
Finally, DropIt~\cite{schwartzDECAF} repurposes a CPU-specific feature
intended for accelerating database transactions to instead mitigate such
bugs.
Bug finding techniques, however, are insufficient --- they can only fix
bugs found, and both static and dynamic analysis are incomplete.
The significant churn in code further complicates the challenge, as every
change potentially introduces a new such bug.
DropIt's mitigation is also incomplete, since the protection depends on
a vendor-specific feature, which has since also been deprecated on newer
processors.
The system call interface requires a more principled and reliant
mitigation against data race attacks.
Similarly, while researchers and processor vendors continue to propose 
mechanisms for finer-grained isolation within a process' address space, 
these mechanisms vary in their design goals, and do not adequately
support widespread adoption.
Mechanisms which prioritize backward compatibility with existing 
systems~\cite{LittonVE0BD16, HsuHEP16, HedayatiGJCSSM19Hodor, LeeSK18, DuHXZC19XPC}
introduce the security benefits of intra-address space isolation
but continue to suffer the consequences of other legacy design choices, 
such as expensive supervisor-mediated context switches.
Some mechanisms~\cite{ParkLXMK19, HedayatiGJCSSM19Hodor} trade off 
performance for security, either providing weaker security than processes
to provide better performance or making restrictive assumptions on
use case.


% Insights: Problems with abstractions can be fixed. 
% Fixes might require principled changes to the interfaces, as either mitigations which preserve the
% interface but allow additional checks to be implemented, or as a redesign of the entire interface.
% In this thesis, we solve the two interfaces by:
% \begin{itemize}
%   \item We recognize that
%           TOCTTOU comes in the insight that devs make an implicit assummption.
%         System calls implicitly assume that their view of accessed user memory does not change
%         during the system call's lifetime. 
%         The kernel uses a well-defined software interface to access user memory. 
%         The clean separation of the access interface allow additional checks to assure that 
%         the implicit invariant is upheld.
%   \item The hardware is part of the TCB, and can be tasked with managing permissions for different
%         compartments, read from one two-D table.
% \end{itemize}
Security guarantees should inform the design of interfaces --- either by 
extending or redesigning interfaces.
% 
At the kernel-user interface, we see that data races require the kernel
to access the same argument in user memory at least twice, which
allows the user to modify the data in the meantime.
In fact, such bugs which are generally called double-fetch bugs commonly 
manifest from the same usage pattern.
The kernel first loads arguments once to check their validity, then
loads them at a later time in order to use them.
This pattern earns these bugs the often-used moniker of 
Time-of-Check to Time-of-Use (\tocttou) bugs.
A double-fetch bug manifests from an implicit assumption by the developer
that the fetched data is the same, which may be violated by another thread
through a concurrent modification.
OS kernels generally use a softare interface to access user memory, to manage
protections like Supervisor Memory Access Prevention (SMAP), and we can
extend this interface with a secure invariant.
% 
Within userspace, however, the requirements for isolation have changed 
drastically: from isolating per-user processes which occupy millisecond-scale
scheduling slots to finer grained module or library-level isolation, which
demands sub-microsecond operations (for example, compartment switching).
An userspace process needs to be further divided into isolated compartments
which can communicate along well-defined APIs.
Software OS mechanisms are expensive --- even IPC-optimized supervisors
on commodity hardware achieve millisecond-scale compartment switches at
best.
We notice that the traditional trusted-computing base includes the hardware
alongside the supervisor.
Hence, we can securely delegate some operations (access control, inter-compartment
control and data flow) from the supervisor to the hardware, improving 
performance while maintaining the same security guarantees.
Improvements and trends in microarchitectural design, such as the trend towards
VMA-based access control in the core's translation-lookaside buffer 
(TLB)~\cite{0003BOBFP21midgard} greatly assist in this transition.


% Solution:
% We solve the security issues at the interfaces by:
% \begin{itemize}
%   \item Fixing the interface implementation. 
%         We introduce a mitigation at the kernel-user interface tasked with maintaining
%         the implicit assumption.
%         We solve the kernel TOCTTOU problem by maintaining a strong invariant:
%         all reads from user memory return the same value throughout the lifetime of the system call.
%         We implement multi-version concurrency through the user-memory read method (read from user).
%   \item Enriching the interface implementation to enable developers to express their
%         trust model and relationships. 
%         We solve the compartmentalization problem by defining a new architectural virtual memory
%         interface, where the hardware isolates compartments based on permissions stored in a 
%         two-dimensional table, and tracking per-core executing compartment, along with 
%         userspace instructions for accelerating compartmentalization operations.
% \end{itemize}
In this thesis, we present secure designs for the kernel-user and user-user
interfaces, both of which are security- and performance-critical.
Midas provides systematic protection to the user-kernel interfaces against
double-fetch attacks by maintaining an invariant:
\emph{through a system call's lifetime, every read to a userspace object
will return the same value}.
Midas can also be extended as a sanitizer, enabling detection of \tocttou
attacks against the kernel.
To validate the design, we also present an implementation of Midas on the
Linux kernel.
SecureCells, meanwhile, is a compartmentalization mechanism providing isolation
between interacting userspace compartments.
SecureCells' design is based on three pillars: hardware-enforced access 
control for isolation, unprivileged instructions for accelerating common
operations and flexible software operations where necessary.
SecureCells is the first mechanism to combine the security and performance
requirements for flexible fine-grained intra-address space 
compartmentalization.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Deeper dive into kernel TOCTTOU protection
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Kernel \tocttou Protection Overview}

% Context
% \begin{itemize}
%   \item The design of many modern operating system kernels heavily draw inspiration from UNIX.
%         These kernels have progressively developed to incorporate modern features and modern
%         security models.
%   \item System call interfaces were designed in the era of uniprocessors.
%   \item Userspace was suspended during kernel syscall processing.
%   \item Multi-threading was not commonplace.
% \end{itemize}
The operating system (OS) kernel is a key component of modern computer systems,
tasked with multiplexing resources like memory, execution time and I/O among
users on a shared machine, or among different tasks by the same user.
The kernel is part of the system's trusted computing base (TCB), and interacts
with untrusted userspace processes through system calls (syscalls).
The userspace/kernel interface is a security-critical barrier, and forms the
primary attack vector for attacker processes to compromise an entire system.
The kernel must, therefore, implement extensive checks at this interface to
protect itself from malicious arguments to syscalls.
Most modern OS kernels trace their heritage to systems designed or developed in
the 1980's and 90's. 
The Linux, Darwin/XNU (used by MacOS) and FreeBSD kernels are all 
mostly compatible with the POSIX interface, first defined in 
1988~\cite{AtlidakisAGMN16}.
The POSIX interface, itself, draws inspiration from the UNIX kernel first
published in 1971.
Over this time, the computing landscape has evolved immensely.
Whereas the original UNIX kernel was not designed for multi-tasking, the
modern desktop, server or mobile computing environment involves a 
multi-user, multi-tasking, multi-processing systems connected via internal
or internet interfaces.
Kernel security has come under ever-increasing threats, and requires stronger
protection guarantees.
% CHATGPT version:
% The kernel of an operating system (OS) constitutes a pivotal element within
% contemporary computer systems, assigned the critical task of resource 
% multiplexing, including memory, execution time, and I/O distribution among 
% users sharing a common machine or among diverse tasks initiated by the same user. 
% As an integral component of the system's trusted computing base (TCB), the kernel 
% engages with untrusted userspace processes through system calls (syscalls). 
% The interface between userspace and the kernel emerges as a security-critical 
% boundary, representing the primary avenue through which malicious processes may 
% compromise the entire system. 
% Consequently, the kernel must implement rigorous checks at this interface to 
% safeguard itself against potentially malicious arguments passed through syscalls. 
% The lineage of most contemporary OS kernels can be traced back to systems 
% conceived or developed during the 1980s and 1990s. 
% Noteworthy among these are the Linux, Darwin/XNU (utilized by MacOS), and 
% FreeBSD kernels, all predominantly adhering to the POSIX interface, initially
% formalized in 1988. 
% The POSIX interface itself draws inspiration from the UNIX kernel, first 
% documented in 1971. 
% Across this temporal expanse, the landscape of computing has undergone 
% profound transformation. 
% While the original UNIX kernel lacked provisions for multitasking, the 
% present-day computing milieu encompasses multi-user, multitasking, and 
% multiprocessing systems interconnected through internal or internet 
% interfaces, spanning desktops, servers, and mobile platforms. 
% The escalating threats to kernel security necessitate heightened protection 
% guarantees. 
% As computing environments become more intricate and interconnected, the 
% imperative to fortify kernel security intensifies, underscoring the 
% exigency for robust defensive measures.


% Short introduction on the Kernel TOCTOTU problem.
% \begin{itemize}
%       \item User space uses system calls to request operating system kernel operations
%       \item System call arguments are passed through registers and through memory
%       \item Kernel reads userspace memory, sometimes in separate accesses for checks
%             and use (TOCTTOU)
%       \item Concurrent or parallel userspace threads sharing the address space can 
%             modify the arguments in memory
%       \item Earlier kernel code implicitly assumes that userspace is paused while
%             syscall executes. This assumption would be almost certain in less
%             adversarial environments, and on single-core computers.
%       \item Today, the kernel works with different threat assumptions, however, 
%             vulnerable code still remains, despite efforts to eliminate TOCTTOU.
%             Partly due to implicit assumptions
%             by developers, sometimes due to legacy code.
% \end{itemize}
Untrusted userspace processes interact with the kernel using system calls,
passing arguments by value (through registers) or by reference (in memory).
When an argument is passed by reference, and the kernel loads the same
value twice, an attacking user process can leverage the temporal window 
between the loads to modify the value in memory, potentially triggering a
kernel bug.
Double-fetch bugs plague operating system kernels, but also extend beyond
to the similar OS-hypervisor interface~\cite{cve201812633, cve202012652, 
cve20131332, cve201920610,cve20158550, cve201610439, cve201610435, 
cve201610433, cve20195519,cve20168438}.
For example, the user could pass a buffer, and its corresponding length
as arguments, then later maliciously change the length to influence the
kernel to access memory outside the buffer.
A time-of-check to time-of-use (\tocttou) violation occurs when the
first read is used to validate an argument (example, the length above)
and the second read is to use the argument.
Double-fetch bugs might be particularly difficult to identify, as the two
reads might be in entirely different parts of the kernel, or even in external
code loaded through the eBPF interface or as modules.
Additional kernel security, such as through system call filters like 
SecComp~\cite{seccomp}, could also introduce double-fetches if extended to
include ``deep argument inspection'' (i.e., arguments passed by reference).

% Insight and design/solution mixed together
A systematic mitigation for double-fetch bugs must prohibit all concurrent
changes to memory accessed during a system call, including from within
threads in the same process, other processes, or from other system calls.
The userspace memory access interface can be tasked with maintaining
the core invariant: 
\emph{through a syscall's lifetime, every read to an usespace object
will return the same value}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Deeper dive into userspace compartmentalization
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Intra-address Space Compartmentalization Overview}

% Context
% SecureCells tackles the challenge of tailoring existing abstractions to keep up to date
% with modern threat models.
% Over the years, code sharing has become increasingly commonplace, essentially
% removing duplication of programmer effort, and allowing consumers to access
% vastly varying computing experiences.
% These experiences are enabled by:
% \begin{itemize}
%   \item Libraries (open-source or binary-only) distributed and shared widely across
%         programs, implementing widely-used operations like cryptography or
%         parsing common file formats. Often such code is available through package 
%         managers like apt or npm as source code or binary blobs. 
%         The intricate web of dependencies between libraries often results in
%         additional code being included.
%   \item Extensible frameworks like the linux kernel allow functionality to be added
%         on-demand, through the use of external code (such as kernel drivers or eBPF
%         payloads),
%   \item On-demand code being distributed to power interactive experiences on the web.
%         Websites are powered by vast code-bases of JavaScript, PHP and Wasm which are
%         dynamically loaded from servers and executed in sandboxes.
% \end{itemize}
% In all of these cases, an address space runs code written by a variety of different
% sources, with different levels of trust and testing, and with a significant code 
% churn.
The complexity and rapid pace of change of modern software systems inevitably
leads to a plethora of bugs across the stack.
Additionally, a system's software is extremely varied, including interacting
subsystems, numerous different applications each relying on a extensive list
of shared libraries, plugins, interpreted code and on-demand downloaded
code, interacting over untrusted I/O interfaces such as the network, disks, 
various accelerators and peripherals.
To manage this growth, software developers heavily rely on
abstraction and isolation.
Each software component hides much of its complexity behind an accessible
interface (commonly called Application Programming Interfaces or APIs).
An operating system kernel is tasked with system management and with 
isolating individual applications.
The hardware provides the abstraction of separate privilege levels, aiding
the kernel to isolate itself from untrusted userspace by inhabiting separate
privilege levels.
The kernel and hardware coordinate to provide the abstraction of processes,
isolated and private virtual address spaces along with separate copies of
kernel resources like file descriptors, used by userspace to isolate
applications.
These abstractions provide crucial security and robustness guarantees.
Applications cannot access other applications' memory spaces, or the
kernel's data.
The kernel can gracefully handle an application faulting, killing the
corresponding process without affecting itself or other applications.
Essentially, these abstractions work to mirror the trust relations between
components of the massive code base.

% Problem
Rapid development in computing, supercharged by the explosion of the internet,
have rendered traditional isolation abstractions insufficient to express modern
trust relations.
A browser, for example, contains hundreds of shared libraries and executes
code downloaded from untrusted websites.
To prevent website code, controlled by a remote adversary, from directly 
accessing local resources, modern browsers are already compartmentalized into
two components: 
an outside-facing rendering engine running in one process 
interacting with 
a separate inside-facing kernel process
using a well-defined API over remote procedure calls (RPCs).
This architecture is motivated by the browser's strong security requirements,
but limited by the coarse-grained abstraction of isolation (processes)
available on traditional systems.
Bugs in the sandbox within the rendering engine can still compromise all
other components in the sandbox, including the just-in-time compiler.
The key limitations of the process abstraction are:
\begin{inparaenum}
      \item all code within a process is equally privileged and can access all
            of that process' resources including memory, and
      \item interactions between processes incur microsecond-scale kernel
            operations.
\end{inparaenum}
The first limitation prevents untrusting components within a process to
isolate themselves, barring software sandboxing which can be buggy at scale.
The second downside limits how finely applications can be decomposed into
processes, due to considerations of performance overhead.
However, the process abstraction is flexible and remains the mechanism 
of choice for usable isolation.

% Insight and design/solution
Modern software requires an intra-address space compartmentalization mechanism
that provides strong isolation within a process' address space, with
low-overhead nanosecond-scale operations to support compartments with short
nanosecond-scale execution timescales, all while maintaining the flexibility
to support a variety of software trust relationships.
In this work, we highlight that the limitations of the process abstraction
stem from the software-hardware design of virtual memory.
First, page-based virtual memory requires permission and translation tracking
at page granularity, and near-core permission caching buffers (TLBs) whose
entry count cannot scale with the rate of growth of memory.
Second, the privileged kernel is tasked with changing between memory 
permissions (involving changing page tables) and incurs the unacceptable
cost of kernel entry and exits.
% TODO: here, the text starts getting wishy-washy
While the hardware is part of the trusted-computing base, its view of virtual
memory remains rooted in the designs of the 80s.
A compartmentalized abstraction of virtual memory, with the hardware capable
of tracking compartments and enforcing the requisite permissions to memory
can eliminate the kernel overheads, while preserving strong security checks.
Further, the hardware can accelerate specific common compartmentalization
operations for data and control flow if it is aware of compartments.
Finally, operations which do not benefit from hardware acceleration can
be retained in software, retaining the accompanying flexibility.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Zoom out, present the thesis statement
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Thesis goals}

This thesis aims to redesign systems interfaces to satisfy the
security and performance requirements of modern and future computing 
systems, against contemporary threat models.
While the security of current systems is of paramount importance, the
performance of these systems must also satisfy strict deployment 
requirements.
Foremost, we prioritize the security of our proposed interfaces, but also
consider performance as a crucial secondary requirement.
For the user-kernel interface, we also consider backward compatibility with
the existing system call semantics as an essential requirement.
For intra-address space compartmentalization, we also deem the flexibility
of the interface to support varying softare use-cases to be vital for adoption.

\begin{center}
      \textbf{Thesis statement}

% \emph{
% The design of interfaces decisively influences the characteristics of 
% computing systems --- 
% strong, well-defined guarantees at the interfaces allow developers to build 
% well-protected high-performance systems.
% Systems software requires reimagined interfaces to reflect the security
% and performance requirements of modern software, particularly at the 
% user-kernel and intra-process boundaries.
% }

\emph{
      Critical software systems are limited by legacy interfaces, 
      and require redesigned interfaces to protect against the modern 
      threat landscape while satisfying strict performance requirements.
      User-kernel and intra-user interfaces particularly benefit from 
      better low-overhead isolation.
}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Thesis contributions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Thesis contributions}

\mat{What about using the attack as motivation?}
\atri{Not sure, which attack?}
% Summary of contributions
This thesis presents two redesigned security- and performance-critical 
interfaces, particularly at the user-kernel boundary and within a process.

\subsection{Midas}
Midas presents a multi-versioning concurrency control mechanism, inspired
from database systems, for maintaining its invariant during user data
accesses.
A \emph{security property} derived from this invariant is enforced ---
Midas uses kernel metadata to track userspace pages accessed, maintains
page-table permissions to enforce immutability and leverages page faults
to on-demand duplicate pages where necesssary to preserve an original
copy for a system call.
A \emph{correctness property} is described and proved in this thesis,
showing how the system execution remains correct under execution with
Midas.
The user-kernel interface is also performance-critical and affects the
system's performance on syscall-intensive workloads.
As concurrent writes to system call arguments is practically non-existent
for well-behaved programs, we have optimized Midas' design to minimize 
expensive page duplications.

% Use cases
% We eliminate TOCTTOU in a systematic solution which will:
% \begin{itemize}
%       \item Protect current (potentially unknown) TOCTTOU bugs in the kernel,
%       \item Protect vulnerable kernel modules or ebpf code developed 
%             by third parties,
%       \item Protect older systems with minor updates.
% \end{itemize}
Midas can be used in various scenarios. 
First, Midas protects systems against existing, even potentially unknown,
double-fetch bugs on current and future production systems.
Second, Midas can protect the kernel against double-fetch bugs in code
dynamically added to the kernel such as modules and eBPF code.
Third, Midas can help extend the functionality of system call filters,
enabling examination of arguments passed by reference without the introduction
of vulnerable double-fetches.
Finally, Midas can protect older systems where updates for modules or other
vulnerable components might be discontinued with a single update to the
kernel core.

% Results summarized
We have implemented a Midas prototype for the Linux kernel, demonstrating its
practicality, and evaluated the system's performance during system-call
dependent workloads from the NAS Parallel Benchmark Suite (NPB) and the
Phoronix Test Suite (PTS).
Midas results in an average performance overhead of $3.7\%$ on NPB and
$3.4\%$ on PTS.
We also perform a security evaluation to demonstrate that Midas successfully
stops an attack against a vulnerable system call.

\subsection{SecureCells}
% What does SecureCells do and provide?
% SecureCells proposes a novel architecture, comprising
% \begin{itemize}
%   \item Compartmentalized virtual memory, with the hardware MMU responsible for
%         enforcing access control to memory across isolated compartments, based on 
%         per-core compartment identifiers and permissions stored on an in-memory
%         two dimensional table storing per-compartment, per-virtual memory permissions,
%   \item Userspace instructions, securely accelerating common compartmentalization 
%         operations implemented as hardware execution units, microcode or firmware,
%   \item Software operations, flexibly adding the remaining functionality with the
%         same security or performance guarantees as hardware.
% \end{itemize}
In this work, we also present a comprehensive set of objectives for a 
compartmentalization mechanism to support widespread adoption.
SecureCells presents a novel virtual memory architecture for secure, 
high-performance, flexible intra-address space compartmentalization.
SecureCells maintains the strong security guarantees of process-based isolation
for fine-grained compartments within a process, with a mix of hardware and
software support.
SecureCells tracks the compartment executing on a core, and implements access
control to memory regions based on a supervisor determined permission table
stored in memory.
Additionally, SecureCells provides unprivileged instructions to implement
fast compartmentalization operations, specifically inter-compartment calls,
zero-copy permission transfer to data regions, and to manage lifetimes for
data regions.
Each of these instructions includes specific checks and controls to maintain
specific security properties, including preventing privilege escalation,
code injection and data races.
Finally, SecureCells delegates operations to software when the corresponding
hardware implementation would bring no advantage.

% Implementation and results
This work also describes our prototype SecureCells implementation, including
the RTL description of an in-order core based on the RISC-V RocketChip design,
a QEMU port for quick emulation, porting of the seL4 microkernel operating
system, and simplified versions of server benchmarks.
We investigate the performance characteristics of our prototype core, using
microbenchmarks designed to test the limits of access control, compartment 
switching and dataflow between compartments, and compare them to related work.
SecureCells' in-order core can switch between compartments (a key performance
metric) in as few as 8 cycles, which compares favourably to state-of-the-art
compartmentalization mechanisms and is orders of magnitude faster than the
traditional process abstraction.
We also demonstrate that SecureCells can help isolate the networking and
data storage of a \Code{memcached}-like benchmark with a small ($<3\%$)
overhead even for the smallest requests.
These improvements are a direct consequence of tailoring the software-hardware
interface to the requirements of modern programs.


% This thesis contributes the design and implementations of modern
% security- and performance-critical interfaces to support 
% current and future computing systems.
% Midas redesigns the userspace memory access interface to provide
% strong mitigations against data race attacks.
% SecureCells introduces compartmentalization to the architectural
% virtual memory interface.

% Midas' design is based on the following insights:
% \begin{itemize}
%   \item Modern OS kernels rely on softare interfaces to access
%         user memory, disabling and re-enabling related
%         protection measures like SMAP.
%   \item Non-adversarial userspace software will not modify
%         system call arguments passed by reference, as they
%         rely on the system call completing successfully.
%         Data races are, therefore, not the common case, and
%         the protection mechanism should be designed for better
%         performance when not under attack
%   \item Duplication of userspace memory is expensive, requiring
%         the corresponding memory allocation and expensive
%         metadata tracking.
%   \item The kernel does not need to duplicate userspace memory
%         except in the case of concurrent updates. In the common
%         case, duplication should be avoided.
%   \item MMU-based permission checks are ubiquitious in modern
%         architectures, allowing the hardware to efficiently
%         enforce read-only access to memory regions, and
%         notify the OS on violations.
% \end{itemize}
% This thesis contributes a design for system-call protection for Linux
% based on these insights.

% In this thesis, we also describe the design and implementation of
% SecureCells, our novel architecture for intra-address space
% compartmentalization.
% We
% \begin{itemize}
%   \item Explore the requirements for compartmentalization, and
%         categorize these requirements under performance, security
%         and flexibility umbrellas,
%   \item Present the design of three pillars of SecureCells: 
%         hardware access control, unprivileged userspace instructions
%         and softare operations.
% \end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Thesis Outline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Thesis Organization}
This thesis is structured as follows.

\autoref{ch:midas} describes Midas, the systematic mitigation to
kernel double-fetch bugs.

\autoref{ch:seccells} describes SecureCells, our novel mechanism for
intra-address space compartmentalization.

Finally, \autoref{ch:compreview} contains a comprehensive survey comparing
compartmentalization mechanisms in qualitative and quantitative terms.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Reference the included papers and contributors
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Bibliographic Notes}
This thesis was supervised by my advisors, Prof. Mathias Payer and Prof. Babak Falsafi.
Portions of the thesis describe projects conducted in collaboration with academic peers, 
namely Uros Tesic, Florian Hofhammer, Yuanlong Li, Siddharth Gupta, and Andres Sanchez.
The investigation of \tocttou protection~\cite{BhattacharyyaTP22}, described in \autoref{ch:midas},
was published in the
\emph{Proceedings of the 31st USENIX Security Symposium} in 2022.
The design, implementation and evaluation of SecureCells~\cite{BhattacharyyaHLGSFP23}, 
described in \autoref{ch:seccells}, was published as a conference paper in the 
\emph{Proceedings of the $44^{th}$ IEEE Symposium on Security and Privacy, SP 2023}.

\mat{Other publications not part of this thesis.}
\atri{Not sure what you want about other publications. Should I list them, or their co-authors?}
