\chapter{Introduction}
\epigraph{Testing can only prove the presence of idiots, not their absence. Software is written---for the most part---by idiots.}%
         {\textit{Aristotle}}

% Context, computers are running ever increasing code bases, which are impossible to definitively verify
% and which are getting executed in shared environments all the time.
Computer systems and computing environments have significantly evolved over time.
\begin{itemize}
  \item The complexity and scale of computing systems has increased exponentially for decades. 
  \item The scale of modern systems allows, and also relies on, a large degree of sharing. 
  \item The degree of code sharing has changed dramatically, 
        from 
        code written by individual tech-savvy developers and run on their personal machines
        to 
        code fully written and distributed by corporations and run by users on their personal machines
        to
        code written and distributed by a large variety of sources, and implicitly run in shared environments
        by even unwitting users on personal machines.
  \item Large amount of shared code cannot be vetted even by large corporations (e.g., popular libraries)
  \item Shared code gets distributed by avenues with low checks or measures (e.g., package managers like crate, npm)
  \item Browsers fetch and execute code on-demand from an infinitely varying set of sources.
  \item Consequently, modern systems include a wider range of trust relationships compared to traditional systems.
\end{itemize}

% The core problem: mismatch between interface design and modern computing trust relations
Modern systems are implemented on legacy interfaces, incurring security or performance limitations.
\begin{itemize}
  \item modern systems continue to rely extensively on legacy interfaces. 
  Examples  of these interfaces include the ISA interface and OS system call interface, both of which largely resemble systems from 20-40 years back.
  For example, the virtual memory definition of traditional ISAs focus on isolating different virtual address spaces from each other, whereas modern systems mix code from various untrusted sources within the same address space.
  \item Interfaces might lack the expressivity to express modern trust relations (virtual memory)
  \item Interfaces might include implicit assumptions, including ones not noticed by the developers of the interface, which may be wilfully or unknowingly violated by malicious or buggy code.
\end{itemize}
Problems with two specific interfaces are tackled by this thesis.
\begin{itemize}
  \item The OS interface to userspace lacks protection against concurrent modification by userspace. 
        A contributing factor to this problem could be the relative absence of concurrency, and absolute 
        lack of parallelism when modern operating systems were conceived.
  \item The ISA interface for virtual memory contains a single permission for any address, for all code
        executing within that address space.
        This design was sufficient when programs trusted all of their code, moreso since most computers 
        ran code entirely designed and written by one corporation.
        The relative infancy of the internet meant very limited code sharing, and only among developers when
        at all.
\end{itemize}

% Prior work around fixing abstractions or introducing new ones
Recent work has started tackling this problem at various levels. 
\begin{itemize}
  \item Papers have tried to remove this implicit assumption from the kernel by attempting to find and 
        refactor code vulnerable to userspace TOCTTOU, using methods based on static and dynamic analysis.
        Limitations of existing works includes:
        - protection only against known bugs, 
        - detection of subset of bugs triggered by dybnamic analysis,
        - other shortcomings described in the paper.
  \item Mechanisms (research and production) have tried to introduce additional access control within an
        address space to isolate parts of a program which do not trust each other.
        However, these mechanisms continue to trade-off performance and security guarantees. 
        - Some existing mechanisms offer a thin additional layer of security for very little overhead.
        - Others provide more comprehensive protection, but at high cost.
        A common contributing factor to higher costs is a reliance on more traditional abstractions.
        Particularly, the OS is included in the TCB and tasked with implementing switching between
        protection domains or compartments, assuring security at high cost.
\end{itemize}

% Insights: Problems with abstractions can be fixed. 
% Fixes might require principled changes to the interfaces, as either mitigations which preserve the
% interface but allow additional checks to be implemented, or as a redesign of the entire interface.
In this thesis, we solve the two interfaces by:
\begin{itemize}
  \item We recognize that
        System calls implicitly assume that their view of accessed user memory does not change
        during the system call's lifetime. 
        The kernel uses a well-defined software interface to access user memory. 
        The clean separation of the access interface allow additional checks to assure that 
        the implicit invariant is upheld.
  \item The hardware is part of the TCB, and can be tasked with managing permissions for different
        compartments, read from one two-D table.
\end{itemize}

% Solution:
We solve the security issues at the interfaces by:
\begin{itemize}
  \item Fixing the interface implementation. 
        We introduce a mitigation at the kernel-user interface tasked with maintaining
        the implicit assumption.
        We solve the kernel TOCTTOU problem by maintaining a strong invariant:
        all reads from user memory return the same value throughout the lifetime of the system call.
        We implement multi-version concurrency through the user-memory read method (read from user).
  \item Enriching the interface implementation to enable developers to express their
        trust model and relationships. 
        We solve the compartmentalization problem by defining a new architectural virtual memory
        interface, where the hardware isolates compartments based on permissions stored in a 
        two-dimensional table, and tracking per-core executing compartment, along with 
        userspace instructions for accelerating compartmentalization operations.
\end{itemize}
\section{Kernel TOCTTOU Protection Overview}

% Itemize
\begin{itemize}
  \item The design of many modern operating system kernels heavily draw inspiration from UNIX.
        These kernels have progressively developed to incorporate modern features and modern
        security models.
  \item System call interfaces were designed in the era of uniprocessors.
  \item Userspace was suspended during kernel syscall processing.
  \item Multi-threading was not commonplace.
\end{itemize}

Short introduction on the Kernel TOCTOTU problem.
\begin{itemize}
      \item User space uses system calls to request operating system kernel operations
      \item System call arguments are passed through registers and through memory
      \item Kernel reads userspace memory, sometimes in separate accesses for checks
            and use (TOCTTOU)
      \item Concurrent or parallel userspace threads sharing the address space can 
            modify the arguments in memory
      \item Earlier kernel code implicitly assumes that userspace is paused while
            syscall executes. This assumption would be almost certain in less
            adversarial environments, and on single-core computers.
      \item Today, the kernel works with different threat assumptions, however, 
            vulnerable code still remains, despite efforts to eliminate TOCTTOU.
            Partly due to implicit assumptions
            by developers, sometimes due to legacy code.
\end{itemize}

We recognize this assumption as a core assumption and develop a mitigation
to enforce this implicit assumption.
Our mitigation is based on a strong statement as an invariant. 
Midas enforces that all accesses to user memory from kernel code returns
the same value during the system call's lifetime.
Midas maintains this invariant by maintaining multiple concurrent versions
of user pages when they are accessed by the kernel, in order to keep one
current copy available for writes by userspace and the kernel, 
with zero or more read-only copies available for reads by executing system calls.
Copies are created on demand, only when a page locked by a system call sees
a modifying write.

We eliminate TOCTTOU in a systematic solution which will:
\begin{itemize}
      \item Protect current (potentially unknown) TOCTTOU bugs in the kernel,
      \item Protect vulnerable kernel modules or ebpf code developed 
            by third parties,
      \item Protect older systems with minor updates.
\end{itemize}

Our solution leverages the software user memory access routine, and
hardware-enforced page table permissions.

\section{Intra-address Space Compartmentalization Overview}

SecureCells introduces a novel mechanism for intra-address space compartmentalization,
aiming to provide secure, performant and flexible support for isolation between
fine-grained compartments between a program. 

SecureCells tackles the challenge of tailoring existing abstractions to keep up to date
with modern threat models.
Over the years, code sharing has become increasingly commonplace, essentially
removing duplication of programmer effort, and allowing consumers to access
vastly varying computing experiences.
These experiences are enabled by:
\begin{itemize}
  \item Libraries (open-source or binary-only) distributed and shared widely across
        programs, implementing widely-used operations like cryptography or
        parsing common file formats. Often such code is available through package 
        managers like apt or npm as source code or binary blobs. 
        The intricate web of dependencies between libraries often results in
        additional code being included.
  \item Extensible frameworks like the linux kernel allow functionality to be added
        on-demand, through the use of external code (such as kernel drivers or eBPF
        payloads),
  \item On-demand code being distributed to power interactive experiences on the web.
        Websites are powered by vast code-bases of JavaScript, PHP and Wasm which are
        dynamically loaded from servers and executed in sandboxes.
\end{itemize}
In all of these cases, an address space runs code written by a variety of different
sources, with different levels of trust and testing, and with a significant code 
churn.

SecureCells proposes a novel architecture, comprising
\begin{itemize}
  \item Compartmentalized virtual memory, with the hardware MMU responsible for
        enforcing access control to memory across isolated compartments, based on 
        per-core compartment identifiers and permissions stored on an in-memory
        two dimensional table storing per-compartment, per-virtual memory permissions,
  \item Userspace instructions, securely accelerating common compartmentalization 
        operations implemented as hardware execution units, microcode or firmware,
  \item Software operations, flexibly adding the remaining functionality with the
        same security or performance guarantees as hardware.
\end{itemize}
% \section{Thesis goals}

% This thesis addresses the challenge of securing systems across an evolving
% computing landscape, particularly at interfaces.
% Interfaces within a system are particularly susceptible to security or
% performance shortcomings.
% Different threat models among components, or a misunderstanding of the
% security guarantees of other components, can compromise an entire system.
% Mismatched abstractions also impose performance overheads, as developers
% adapt their code accordingly.




\section{Thesis statement}

The design of interfaces between layers of the computing system stack decisively influence the 
security and performance characteristics of the system --- 
strong, well-defined guarantees at the interfaces allow developers to build well-protected 
high-performance systems.
This thesis improves the user-kernel interface by elevating an implicit assumption to 
an explicit guarantee, preventing a class of data-race driven attacks.
This thesis also proposes an architectural interface for compartmentalized virtual memory
with strong isolation guarantees, by design, at high performance.

\section{Thesis contributions}

This thesis contributes the design and implementations of modern
security- and performance-critical interfaces to support 
current and future computing systems.
Midas redesigns the userspace memory access interface to provide
strong mitigations against data race attacks.
SecureCells introduces compartmentalization to the architectural
virtual memory interface.

Midas' design is based on the following insights:
\begin{itemize}
  \item Modern OS kernels rely on softare interfaces to access
        user memory, disabling and re-enabling related
        protection measures like SMAP.
  \item Non-adversarial userspace software will not modify
        system call arguments passed by reference, as they
        rely on the system call completing successfully.
        Data races are, therefore, not the common case, and
        the protection mechanism should be designed for better
        performance when not under attack
  \item Duplication of userspace memory is expensive, requiring
        the corresponding memory allocation and expensive
        metadata tracking.
  \item The kernel does not need to duplicate userspace memory
        except in the case of concurrent updates. In the common
        case, duplication should be avoided.
  \item MMU-based permission checks are ubiquitious in modern
        architectures, allowing the hardware to efficiently
        enforce read-only access to memory regions, and
        notify the OS on violations.
\end{itemize}
This thesis contributes a design for system-call protection for Linux
based on these insights.

SecureCells contributions
Enumeration of the requirements for compartmentalized software.

\section{Thesis Organization}

This section describes such and such.

That section describes such and such.

\subsection{Bibliographic Notes}
This thesis was supervised by my advisors, Prof. Mathias Payer and Prof. Babak Falsafi.
Portions of the thesis describe projects conducted in collaboration with academic and
industrial peers, namely Uros Tesic, Florian Hofhammer, Yuanlong Li, Siddharth Gupta, 
and Andres Sanchez.
The design, implementation and evaluation of SecureCells, described in 
\autoref{ch:seccells}, was published as a conference paper in the 
\emph{Proceedings of the $44^{th}$ IEEE Symposium on Security and Privacy, SP 2023}.
The investigation of TOCTTOU protection, described in \autoref{ch:midas},
was published in the
\emph{Proceedings of the 31st USENIX Security Symposium} in 2022.

