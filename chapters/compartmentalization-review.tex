Compartmentalization brings security benefits to programs, and can reduce the
costs of other programs.

Compartmentalization can be implemented on various mechanisms.

These mechanisms can lead to varying degrees of isolation and performance.

A survey of compartmentalization mechanisms is required to understand the
properties and guarantees of different proposals.

Deep dive into different features.

%%%%% Parts of this background are already discussed in the SecureCells paper.
%%%%% However, we need not repeat this stuff in this section.
% \section{Background on Compartmentalization}

% \begin{itemize}
%       \item Modern software is monolithic, or compartmentalized at a coarse granularity.
%       \item Monolithic software runs all parts of an application in a single address space
%       \item Issues with monolithic software includes:
%             Memory safety bugs can compromise data throughout the address space
%             Control flow hijack/bending allows any code to call any other code
%             Can lead to system calls being called from unexpected code
% \end{itemize}

% In contrast, a compartmentalized program separates logical components of the application
% and isolates them in individual compartments, which implies some degree of separation.
% Isolation restricts which resources each compartment has access to, in order to prevent
% one or more of the above attack vectors.

% Compartments are logical, and not necessarily linked to code. 
% For example, compartments for a browser can include the JIT compiler, the runtime and the
% untrusted sandbox code. 
% While these are isolated, they may have access to the same code, including libraries like
% libc.
% Additionally, there might be one or more sandboxes which are instances of the same module,
% for example, and thereby share exactly the same code regions. 
% However, they would need to have separate data regions or some isolated contexts.
% All of this is to say that we should not make a 1:1 link between code and compartment.

% The aim of this section is to provide background of compartmentalization as a software design principle to provide enhanced security. 
% This section will explain the terminology of "monolithic" and "compartmentalized" programs. 
% This section will also describe the attacker model for compartmentalization and what attacks can be prevented.


\subsection{Survey of use cases}

Who could use compartmentalization?

What would they benefit from this, security and performance wise?

\subsection{Security Properties from Compartmentalization}
This subsection will describe the security benefits of compartmentalization. This subsection should explain exactly what attack scenarios are protected and which ones are not. At the end of this section, the reader should be clear about what the security guarantees of compartmentalization are. Particularly, we should be clear that compartmentalization does not protect against buggy modules that allow compromise via their external interface.

We will also discuss how specific protections can be provided by mechanisms, and
why they each matter.

For example, why does lack of code-checks in MPK matter?

Why does the lack of exclusive access matter?

\subsection{Performance Properties from Compartmentalization}

What sort of actions do we expect from compartmentalization?

What is their frequency?

How do these affect the performance of the complete program?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introducing the surveyed mechanisms
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{TODO: Introducing our contenders \\ Mechanisms List}

To understand and compare mechanisms, we first need to understand each 
mechanism, and understand their model for compartmentalization.
We want to understand what a program looks like under this model.
What are the relevant abstractions and what their semantics are.

We will attempt to explain what a compartmentalized web browser looks like.
A browser has: 1 JIT compartment, 1 or more sandboxed compartments.
Not strictly hierarchical:
a) sandboxes should have execute permissions on generated code but not JIT
b) sandboxes do not trust each other.

\atri{TODO: add illustration for the browser.}

\subsection{Process-based compartmentalization}

The traditional abstraction of isolation is based on processes.
We will describe process-based compartmentalization in UNIX-like OSs
(particularly Linux), 
but the concepts generalize to other OS kernels.

% Context about how processes emerged
Initially, processes were introduced to isolate programs running on multi-user
processes.
Each process has an isolated memory space (architecturally-defined virtual memory)
and individual OS resources, such as file descriptors, I/O handles or capabilities.
The OS kernel time-multiplexes processes onto one or more processing cores.
A process can have one or more kernel threads, corresponding to independent threads
of execution, but sharing the same address space and OS resources.
Everything within a process shares the same permissions to access its memory and
its OS resources, including the program's executable, libraries, and loaded modules.

% Explain how processes allow compartmentalization
To compartmentalize a program, that program needs to isolate each compartment in
a separate process.
% Isolation part.
Each process will have its own private memory address space, and its own 
OS resources.
One process cannot name a separate process' resources since they each have separate
namespaces, and hence cannot directly access another process' resource.
OS resources require an open-like step, ensuring that each process in the program
only accesses allowed resources.
Processes cannot arbitrarily gain capabilities.
% Communication part
Processes can, additionally, share memory and specific OS resources for 
communication.
Shared memory must be set up with explicit system calls, and are subject to 
syscall filtering.
The generated code region can be shared between the JIT and sandboxes, along
with code sections for shared libraries.
Processes can also communicate using IPC system calls (like sendmsg/recvmsg).
A remote (cross-process) procedure call typically consists of serialization of
arguments into a buffer, sending the buffer across using a system call,
and then deserialization of the arguments on the receiving side followed by
the requisite processing based on the arguments.
As we will show later, the cost of inter-process switching contributes a great
deal to the expensive nature of compartmentalization with processes.

% Explain how processes compartmentalize a browser
A browser isolated with processes has been implemented in Project Chakra.
Per-sandbox shared memory between the JIT and each sandbox holds generated
code. 
This region is mapped rw for the JIT and rx for the sandbox.
Further communication happens through kernel-based message passing.


\subsection{XPC}

% Context and introduction of XPC
XPC shares much of the abstractions from the process-based isolation, but
attempts to accelerate RPC in particular while maintaining much of the same
interface.
Backward compatibility is a major design directive.
Particularly, XPC manages much of the IPC functionality implemented by the
operating system through hardware state machines aiming to reduce the cost
compared to software, and eliminating software dispatch and scheduling 
overheads in the common case.
XPC also focusses on cheap zero-copy data movement between processes,
dedicating a single relay segment for the purpose.

% Explain how XPC allows compartmentalization
A compartmentalized program running under XPC looks essentially identical
to that using processes.
% Isolation part
Just like previously, each process has their own address space and OS 
resources and capabilities.
The XPC hardware engine tracks the page-table pointer and capability pointer
for each process of a compartmentalized program in an \emph{x-entry} held in
an in-memory \emph{X-Entry Table}.
The OS sets up this table during setup.
While a process is running, the XPC engine ensures that the hardware uses the
correct page table pointer and capabilities.
% Communication part
XPC accelerates remote procedure calls, introducing the \Code{xcall} and
\Code{xret} instructions to replace \Code{sendmsg}.
On executing \Code{xcall}, the hardware fetches and installs the relevant 
page table pointer and capabilities for the target process, 
and put an entry for the caller on a \emph{Link Stack}.
Executing \Code{xret} allows the callee to return to the caller, and the
hardware engine pops the caller's information and installs it in the
corresponding system registers (including the return address). 
XPC eliminates the OS kernel from inter-compartment calls, relying on the 
hardware to implement traditional kernel functionality.
Additionally, data passed between processes can use the relay segment, which
is one dedicated segment mapping memory separately from the page tables.

% Explain how XPC compartmentalize a browser
A browser compartmentalized using XPC looks essentially the same as
using UNIX processes. 
The JIT and each sandbox occupy separate processes.
The major change is that IPC system calls are replaced by 
\Code{xcall}/\Code{xret} pairs.

\subsection{Light-weight Contexts (lwC)}
% Context and introduction of lwc
This paper introduces a new eponymous OS abstraction,
Light-weight contexts (lwCs),
which are independent units of isolated execution.
Contexts, like processes, have separate memory address spaces, OS resources,
and capabilities.
However, contexts remain part of a single process, resembling kernel threads.
Contexts offer the primary advantage that switching contexts within a process is 
faster than switching processes, or even kernel threads within the same process.
lwC achieves faster switching between contexts by eliminating unnecessary kernel
processing due to the kernel scheduler and resource accounting.

% Explain how lwc allow compartmentalization
% Isolation part
Contexts diverge from the point of calling \Code{lwCreate} which acts similarly
to the \Code{clone} system call, where each resulting context has an 
independent memory address space and OS resource handles.
Like processes, OS resource handles can persist across a \Code{lwCreate}, or be
invalidated in the child.
Further shared resources can be generated using the \Code{lwOverlay} system 
call.
During program setup, numerous contexts may be created, each of which can
perform private setup steps or further restrict their resource rights using
\Code{lwRestrict}.
% Communication part
Execution of contexts resembles processes, merely replacing inter-process system
calls with the faster inter-lwC switches.

% Explain how lwc compartmentalize a browser
A browser compartmentalized using lwC looks essentially the same as
using UNIX processes. 
The JIT and each sandbox occupy separate contexts, instead of processes.
The major change is that IPC system calls are replaced by \Code{lwSwitch}
system calls.

\subsection{Mondrian Memory Protection (MMP)}
% Context and introduction of MMP
MMP tackles the challenge of flexible, fine-grained intra-address space 
isolation.
Intra-address space compartmentalization differs from previous mechanisms,
all of which have separate memory address spaces for each compartment.
In contrast, compartments in MMP and the following mechanisms all share the
same address space.
Isolation between compartments relies on different 
memory views, i.e., different permissions to the same address for 
different compartments.
Intra-address space compartmentalization can simplify the process of
porting monolithic programs to compartmentalize them, and allow
smaller compartments with fine-grained memory permissions.
Data transfer for intra-address space compartmentalization can be simpler
than with IPC, since addresses remain valid across compartments.

% Explain how MMP allow compartmentalization
% Isolation part
Each compartment in a program compartmentalized under MMP maps to a protection
domain, with an unique \emph{Domain ID}.
The virtual address space is split into a number of segments.
Each compartment has its own permission table which holds per-segment permissions,
essentially allowing the domain to have its own view of permissions to memory.
The permission tables can be configured to allow segments to be private (only one 
domain has permissions), or shared.
MMP also describes different structures for the permissions table in memory, and
the hardware structures to read and cache permissions.
MMP's permissions tables separate permissions from translation, and are
independent of page tables.
Crucially, MMPs permission tables allow segments starting and ending at
word boundaries instead of page boundaries, allowing spatially fine-grained
permissions.
% Communication part
Compartments in MMP can call each other through system calls or traps, 
which also modify the permissions table base pointer register in hardware.
The paper also proposes that hardware can be used to accelerate this switch,
though the mechanism is not clearly explained.
MMP requires call gates to prevent control flow attacks at inter-compartment
boundaries.
Data can also be passed between domains during switching, by marshalling
data into copied buffers.
However, MMP also introduces the concept of zero-copy data passing between
compartments by modifying the permissions to the segments holding passed data.
However, few details on maintaining coherence of on-chip permission buffers 
are discussed.

% Explain how MMP compartmentalize a browser
In MMP, the browser fits in a single address space with separate protection 
domains assigned to the JIT compiler, and for each of the sandboxes.
For each sandbox, the generated code can be assigned a separate segment
which has separate permissions for the JIT domain (rw), and for the sandbox
domain (rx).
Further, transitions between the sandboxes and the JIT engine use protected
calls with call gates which ensure proper checks on these transitions.

\subsection{Code-centric Memory Domains (CODOMs)}
% Context and introduction of CODOM
CODOMs enabled fine-grained intra-address space compartmentalization
with a novel architecture where domains are identified by the executing
instruction pointer (hence the "code-centric" name), and with permissions
to data regions determined by the executing domain. 
Essentially, bits of page table entries identify the domain owning that
page.
Executing an instruction from a page tagged with a domain ID equates to
executing as that domain.

% Explain how CODOM allow compartmentalization
% Isolation part
Domains in CODOM each have permission to specific pages of memory: 
those tagged with that domain's tag in the corresponding page-table entry.
A domain cannot access data belonging to other domains, except if
explicitly allowed during access protection lists (APLs).
% Communication part
Compartments can communicate with function calls, which implicitly
cause compartment switches when the domain of the target address page
differs from that of the source.
APLs specify the ability of some domains to call other compartment,
as well as for the caller to share their data with the callee.
While APLs allow domains to permanently share data with other domains,
CODOMs also proposes the use of capabilities to temporarily share
permissions to data during cross-compartment calls.

% Explain how CODOM compartmentalize a browser
Under CODOM, a browser must have separate pages corresponding to the
JIT engine and for each sandbox. 
Each domain's pages must be correctly tagged in the page table to allow
the domain to be identified by the hardware.
Each sandbox must own the pages holding their code regions, and have
'rx' permissions in the page tables. 
The JIT engine can generate new code using additional permissions specified
in the APLs, where the engine should be granted write permission to
each sandbox's domain pages.
\atri{note: APLs enable access to all of a domain's stuff. sigh.}

\subsection{Intel Memory Protection Keys (MPK)}
% Context and introduction of MPK
Memory Protection Keys assign keys to regions of memory, and maintain
a separate set of access permissions for each key.
While previous implementations in PA-RISC, Itanium and POWER-6 rely on 
supervisor managed protection key permissions, Intel's MPK extension
makes permission changes cheap by allowing userspace modification to
permissions.
MPK uses bits of the page table entry to assign each page a 4-bit color key,
and uses permission bits in the per-core PKRU register to control permissions
to each page color.
PKRU permissions can be arbitrarily changed by userspace, using a special
instruction (\Code{wrpkru}).
A software library (libmpk), can be used to virtualize page colors, allowing
the use of more than 16 page colors.

% Explain how MPK allow compartmentalization
% Isolation part
When executing a compartment, MPK uses permissions in the PKRU register
to enforce additional restrictions on memory access. 
Each core's PKRU register should only have permissions for page colors as
per the compartment executing on that core.
% Communication part
Compartments in MPK can implicitly switch between each other using the 
\Code{wrpkru} instruction to change the core's accessible page colors.
Along with the permission changes, the application can also use 
function calls to implement cross-compartment procedure calls.
Data can be transferred between compartments using shared page colors.
Changing page colors requires page table entry modifications, implying a
system call, and cannot be done as fast as PKRU writes.
MPK lacks call gates, and software must take care to manage control flow
integrity.

% Explain how MPK compartmentalize a browser
A browser can be compartmentalized with MPK, with one page color for the JIT
engine and different colors for each of the sandbox regions.
The PTEs for all generated code regions must have 'rwx' permissions, 
since PTE permissions are also enforced.
During JIT execution, the PKRU register holds 'rw' permissions for the
sandbox code regions.
During sandbox execution, the PKRU register holds 'rx' permissions for that
sandbox's code region, and no permissions for any non-sandbox regions.

\subsection{ERIM}
% Context and introduction of ERIM
ERIM builds on top of Intel MPK to implement strict call gates for
compartment switching, mitigating MPK's main shortcoming.
Essentially, ERIM limits the existence of instructions which can
modify the PKRU value (\Code{wrpkru} and \Code{xrstor}) to within
software call gates.
However, ERIM must inspect all newly loaded code, including shared
library or module loading, to ensure that new instructions which
modify the PKRU register are not injected.

% Explain how ERIM allow compartmentalization
% Isolation part
ERIM relies on the same set of MPK permissions described above to
isolate compartments.
% Communication part
ERIM's main differentiating feature are its call gates, which should
be the only parts in the program with executable \Code{wrpkru} or
\Code{xrstor} instructions.
The key feature of ERIM's call gates are that \Code{wrpkru} instructions
are immediately followed by a call to trusted code, or by a condition which
checks the value in the PKRU register. 
The latter check allows control flow attacks which try to load invalid
permissions to be immediately detected.

% Explain how ERIM compartmentalize a browser
A browser compartmentalized with ERIM essentially looks the same as with
MPK, with the JIT engine occupying a trusted compartment, and each sandbox
occupying one untrusted compartment. 
Data can be passed through pointers directly, just as with MPK, though 
compartment transitions use ERIM's aforementioned call gates.

\subsection{Donky}
% Context and introduction of Donky
Donky aims to retain MPK's primary performance advantage, by allowing
changing memory views in userspace, while mitigating its main weakness, 
where an attacker with arbitrary code execution can immediately bypass
MPK's protections.
Donky replaces Intel's PKRU register register with a new DKRU register
which cannot be directly modified by userspace.
Donky effectively introduces a new privilege level within userspace, 
running a special software monitor called the Donky monitor solely 
capable of modifying the DKRU register.
The Donky monitor can be trapped-into by userspace software, enabling the
monitor to serve inter-compartment call requests, among other requests
which modify memory keys.
While Donky's monitor does not run within the supervisor privilege level,
its design of entry-exit through hardware traps and ability to modify
registers not accessible to normal userspace code makes the Donky monitor
similar to previous works of supervisor-mediated compartmentalization.

% Explain how Donky allow compartmentalization
% Isolation part
Compartments in Donky use separate regions of memory, with permission
enforced as per the DKRU register, similar to compartmentalization with
MPK.
These permissions allow memory isolation for compartmentalization.
% Communication part
Compartments can call each other using \Code{dcall}s, essentially trapping
into the monitor which modifies permissions in the DKRU register and
sanitizes register values before dropping into the callee.

% Explain how Donky compartmentalize a browser
A browser compartmentalized with Donky uses separate Donky domains for the 
JIT engine and for each sandbox, created by calls to the Donky monitor.
The browser can also install \Code{dcall}s between the engine and each
sandbox, but prohibit \Code{dcall}s between sandboxed domains directly.
Each transition between domains using a \Code{dcall} is interposed by the
monitor.
Arguments must be passed through either registers, or through shared memory
between domains.

\subsection{CHERI}
% Context and introduction of CHERI
CHERI introduces architectural support for memory capabilities.
Architecturally, pointers are replaced capabilities, which track 
spatial bounds of memory accessible using that capability. 
CHERI compartmentalization repurposes CHERI capabilities, with a customized
kernel to provide intra address-space compartmentalization.
CHERI provides compartmentalization based on the object-capability model, 
where each compartment is represented as an object encapsulating capabilities
for the compartment's code and data regions.
CHERI is drastically different from the previously mentioned mechanisms,
as access permissions for a compartment are not stored in a centralized
permissions table or permissions register.
Instead, CHERI relies on capabilities distributed within a compartment's 
registers and data regions.

% Explain how CHERI allow compartmentalization
% Isolation part
CHERI uses the capabilities to memory to spatially limit the memory regions
accessible to a compartment.
When executing, CHERI requires one or more code and data capabilities. 
For compartmentalization, each compartment encapsulates its code and data
capability within an object, and sealed by an object type capability 
field (\Code{otype}). 
When running as that compartment, those capabilities are installed in CPU
capability registers, allowing the compartment to only access its code and data.
% Communication part
Compartments can call each other using a system call to the CheriBSD kernel,
which securely saves the caller's state to its object, and unseals the
callee's code and data capabilities and installs them in the core's registers 
before dropping into the callee.
Further, CHERI's capabilities greatly simplify passing permission to arguments
during an inter-compartment call.
A CHERI caller can simply pass a capability to the argument in memory during
the call, allowing the callee to use the capability to access the corresponding
memory.
One consequence, which the caller must be careful about, is that the callee can
use any capabilities stored in this argument memory region to further access other
regions of memory.
CHERI compartmentalization, though, lacks a mechanism for revocation,
instead suggesting the use of garbage collectors for eventual revocation.
A key concern for developers will be regarding "leaked capabilities" passed during
inter-compartment calls.

% Explain how CHERI compartmentalize a browser
With CHERI, each of the browser's compartments must be allocated a separate
object encapsulating that compartment's code and data.
Both the JIT engine and sandboxes must each hold capabilities to the
sandbox's code region. 
The JIT engine can use its own capability to a sandbox's code region,
permitting 'rw' operations, to generate new code for the sandbox.
The sandbox's own capability for this region must only allow 'rx' operations.
Finally, the JIT engine can pass temporary capabilities to sandboxes
when they are required to process certain data, including new data packets,
with zero-copy.

\subsection{SecureCells}
% Context and introduction of SecureCells
SecureCells introduces a compartmentalization mechanism based on hardware
access control to variable-sized regions of memory, hardware tracked
compartment identifiers, a unified permissions table for all compartments,
and unprivileged instructions for securely accelerating common operations.
SecureCells' permissions table stores permissions for each compartment to
each data region.
Further, SecureCells' userspace instructions enable control flow and
zero-copy data movement between compartments with unprivileged instructions.
SecureCells' unprivileged instructions implement hardware checks in order
to prevent privilege escalation.

% Explain how SecureCells allows compartmentalization
% Isolation part
Each compartment in SecureCells is assigned a \secdiv{}, whose accesses
to memory regions are checked with an in-memory permissions table.
Properly configured permissions allow compartments to have private regions
to which on that compartment has permission, and selectively shared regions
with specific other compartments having permission. 
When executing code for a compartment, a core tracks the executing compartment
identifier in a system register, and accordingly presents a view of memory.
% Communication part
Compartments can also interact with unprivileged \Code{SDSwitch} instructions
which atomically  switch to a different compartment and jump to the callee's
entry point.
To aid zero-copy data transfer, SecureCells also includes unprivileged instructions
which move permissions for regions between compartments.

% Explain how SecureCells compartmentalize a browser
A browser compartmentalized with SecureCells will require separate
\secdiv{}s for each sandbox and for the JIT engine.
The permissions table is set up with per-sandbox private regions, to which
only each sandbox and the JIT engine have permission.
The permissions can allow the JIT engine 'rw' permissions and a sandbox
'rx' permissions to that sandbox's code region.
The JIT engine can use \Code{SDSwitch} to enter and exit sandboxes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introducing the classification metrics
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Points of Classification/metrics}

\subsection{Threat Model}
Hierarchy?
Single trusted?
OS trusted?
Code injection allowed?

\subsection{Access Control Permissions}

Compartments are under access control. 

First, data accesses need to be checked. 
Otherwise, an attacker can compromise a compartment to directly access another
compartment's data.
Second, an attacker can "inject" fake data in their own compartment, and 
manipulate the victim to access it (maybe confusing this data for their own).
With data checks, the second step will fail even if the first succeeds.

Instruction accesses need to be checked, without which three are a 
couple (? maybe only one) of different attack vectors.
First, code injection becomes simplified without instruction access checks.
An attacker can inject malicious code in their own compartment, then needs
to influence the victim to execute that code (leveraging some existing bug).
With instruction checks, the second step will fault, even if the first step
succeeds.
Second, data can be held in executable sections, encoded in instructions for example.
Imagine a JavaScript sandbox whose code is generated on the fly. 
The existence/lack of particular code can indicate particular JavaScript which has
been executed, and thereby linked back to specific secrets in JavaScript.
Cross-sandbox code execution can, therefore, leak data through this side channel.

Processes implement both data and code access checks. 
Further, each process decides what data/files get mapped into their address space.
However, this can also lead to problems where a process can map a file without
consent (refer to a separate subsection).

XPC and lwc are based on process-like abstractions, and both have proper
code and data access control.

MPK implements data checks, but lacks code checks. 
This is likely motivated by performance reasons/ease of implementation.
ERIM and libmpk, which build on MPK also lacks code access checks.
Donky, which is inspired by MPK, also lacks code checks.

CHERI compartmentalization requires capabilities for code execution and
data access. Satisfactory security.

CODOMs link code to compartments, and has no code sharing.
Implicitly has code access control.
Also has data checks.

MMP has both code and data access control.

\subsection{Intra compartment call gates}

Compartments typically implement separate functionality, and
need to coordinate to achieve the program's desired functionality.
Programs will have some compartment call another compartment to
do some processing.
When compartments interact, 
\begin{itemize}
      \item Compartments must implement checks to secure the interface:
            Arguments must be checked, caller-callee pair must be
            allowed.
            Other restrictions might apply, based on application.
      \item Checks can be in hardware or software, or a mix of both.
            Common checks can be in hardware, software allows 
            application-specific checks.
      \item Should not be possible to elide checks.
\end{itemize}
To assure the above, inter-compartment control flow must follow call gates
which implement the requisite checks.
Call gates must be entered at the start, to prevent ROP-style attacks.

Suppose a compartment starts with argument validation and then proceeds to
using the arguments, lack of call gates can allow an attacker to run the 
compartment directly with invalid arguments by entering just after the
checks.

Migrating threads can similarly cause issues if an attacker calls a victim
with malicious register state.
An attacker might, for example, force a victim to execute with an illegal,
attacker-crafted stack.

Execution following a call-gate entry must stay secure, specially if using
migrating thread model where the execution continues with the caller's 
context.
Migrating thread model is insecure in the general case. 
Can be made secure through formal checks on code (possible for small code)
or through adaptation into static threading through the addition of context
switching.

Requirements are:
- checked entry point(s)
- secure execution/secure context switch.

Processes have secure entry points, and use static threading.
Kernel system call return points following IPC wait calls are implicit
entry points. 
Callers cannot enter at arbitrary address.
Kernel also maintains thread context during system call, so context is
restored before system call returns.

XPC maintains the same model as processes, but maintains entry points/call
stacks in hardware.
Also maintains state, maybe.

MPK lacks call gates. 
PKRU value can be changed any time, but no intra-address space control-flow
guards are provided.
MPK also lacks explicit tracking of executing compartment.
Therefore, no way to distinguish whether context is correct/switch to correct
context.
libmpk adds nothing more.

ERIM adds call gates to MPK.
Call gates cannot be bypassed, therefore control flow attacks become impossible.
However, big performance penalty.

Donky adds the pseudo-privileged library to protection keys.
Similar to processes, this maintains control flow integrity and entry points.
(Gotto check) Donky reverts to static threading.

CHERI also relies on the supervisor, and provides both checked entry points
and contexts.

SecureCells has lightweight inter-compartment entry checks.
Static threading can be implemented on this base.

CODOMs does not have call gates. 
Any jump will implicitly switch compartments based on the source and target
instruction pointers.

\subsection{Zero Copy data movement}

When compartments communicate, they also send data across the interface.
A common framework for data transfer between processes uses protobufs
to serialize data (aggregate data from different data structures into
a serial form), copy data via a system call (likely sendmsg for Linux),
and deserialize the information at the receiver.

The Communication interface also comes with a potential security
issue.
If a compartment can unilaterally inject permission to code or data
into another compartment, that can lead to confused deputy attacks where
the target uses the transferred information under the confusion that the
data is its own. 

While the RPC framework is flexible, it suffers from limited performance.
In specific cases, systems can benefit from moving permissions to memory
instead of copying the data over.
This advantage becomes more pronounced for larger data movements.
In particular cases, zero-copy data transfer offer the sole practical
opportunity to satisfy strong performance requirements. 
Key example is networking functions.
However, the RPC interface is also secure. 
The receiver of the RPC must explicitly use a syscall to accept an 
incoming RPC.
Further, incoming RPCs necessarily appear as data, not code.

A trade-off for zero-copy data movement is that the involved data needs
to be serialized, and programs that naturally deal with serialized buffers
profit with ease.

CHERI's capability model offers a natural fit to zero-copy permissions 
transfers, as access to a buffer passes along with the pointer when passed
as cross-compartment capability arguments along with all contained 
capabilities.
A single capability argument can grant access to a complex data structure
across multiple regions, alleviating the need for serialization.
This power, however, must be used with care.
If any unwanted capability is leaked, anywhere within the nested structures,
CHERI can be compromised.
CHERI's capabilities also resemble unilateral information transfers.

XPC offers hardware support for zero-copy transfer for one segment, which can
be subsequently monotonically shrunk in nested RPC calls.
Great for performance, but limited use cases: only those programs which can
be shoehorned into this shell.
XPC's information injection is also restricted to data, but is unilateral.

Protection key-based methods (MPK/libmpk/ERIM) can offer zero-copy permission
transfer to all pages with the same color, simply by writing the correct
permissions to the target compartment's key.
However, this is all or nothing.
Protection keys give very little protection against injection of code/data.

SecureCells allows zero-copy permission movement. 
Crucially, 
\begin{itemize}
      \item transfers require a handshake
      \item it allows unlimited segments to be moved
\end{itemize}
However, all or nothing: entire cell gets transferred.
SecureCells does not support efficient shrinking of data regions.

\subsection{Flexibility/Generic support}
\atri{A lot of stuff here seems wishy-washy. Not convincing.}

Flexibility in a mechanism will allow it to be used with a variety of
use cases/applications.

For example, can a mechanism support the large degree of code sharing
within modern programs?
Can a mechanism support a non-hierarchical trust relation between
compartments?

Mechanisms which specialize for sandboxing will not be able to
support mutually distrusting compartments without intervention via a
trusted runtime compartment.
\atri{give examples} (IMIX, ERIM, MemSentry)

CODOM identifies a compartment by its program counter, i.e. code has a
1:1 link with compartment.
For example, multiple JavaScript sandboxes will not be able to share
a library for, say, cryptographic operations.
In such a case, a common design might be to isolate different
cryptographic contexts corresponding to different compartments, but
share the library code which operates on those contexts.

Mechanisms which can configure which protections are used can offer a
security-performance trade off where justified.
Using Mach's migrating thread model might be good.

While Linux' process model semantics are nigh impossible to change, due to
a large focus on not breaking userspace, many operations are implemented
in software and allow change.
Cloud providers, or other users, can modify Linux, and make changes which
improve performance. 
Light-weight contexts follows this principle (based on FreeBSD, not Linux).
Other uses include fast IPC models. 
Only the system call entry and return, and use of privileged instructions
for changing address spaces, rely on hardware and cannot be elided.

CHERI implements its own supervisor, relying on a few key privileged
operations to seal and unseal encapsulated capabilities.
Remaining stuff may be customizable?

XPC would support existing applications using RPC. 
However, nothing can be added or removed, since the entire abstraction
is implemented in hardware and centred around today's (g)RPC interface.
XPC limits the sharing segment to a single instance.

LOTRx86 and HODOR rely on specific implementations of Intel's
extensions to x86. 
These mechanisms cannot be later run on other architectures, like
ARM or RISC-V.

SecureCells offers a little bit of flexibility with context switching.
However, the PTable is quite open.
SecureCells does not depend on architecture-specific features.
However, SecureCells mixes protection and translation near the core,
and requires segment-like allocation of physical memory for virtual
memory ranges.

% \subsection{Backward compatibility}
