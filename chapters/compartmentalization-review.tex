Compartmentalization brings security benefits to programs, and can reduce the
costs of other programs.

Compartmentalization can be implemented on various mechanisms.

These mechanisms can lead to varying degrees of isolation and performance.

A survey of compartmentalization mechanisms is required to understand the
properties and guarantees of different proposals.

Deep dive into different features.


\section{Background on Compartmentalization}

\begin{itemize}
      \item Modern software is monolithic, or compartmentalized at a coarse granularity.
      \item Monolithic software runs all parts of an application in a single address space
      \item Issues with monolithic software includes:
            Memory safety bugs can compromise data throughout the address space
            Control flow hijack/bending allows any code to call any other code
            Can lead to system calls being called from unexpected code
\end{itemize}

In contrast, a compartmentalized program separates logical components of the application
and isolates them in individual compartments, which implies some degree of separation.
Isolation restricts which resources each compartment has access to, in order to prevent
one or more of the above attack vectors.

COmpartments are logical, and not necesesarily linked to code. 
For example, compartments for a browser can include the JIT compiler, the runtime and the
untrusted sandbox code. 
While these are isolated, they may have access to the same code, including libraries like
libc.
Additionally, there might be one or more sandboxes which are instances of the same module,
for example, and thereby share exactly the same code regions. 
However, they would need to have separate data regions or some isolated contexts.
All of this is to say that we should not make a 1:1 link between code and compartment.

The aim of this section is to provide background of compartmentalization as a software design principle to provide enhanced security. This section will explain the terminology of "monolithic" and "compartmentalized" programs. This section will also describe the attacker model for compartmentalization and what attacks can be prevented.

\subsection{Modularity and Principle of Least Privilege}
Explaining modularity.
\begin{itemize}
  \item Modularity is a key principle in modern software design
  \item Modularity helps handle exploding code complexity, simplifies design
  \item Modules are clustered around separate functionality
  \item Modularity lends itself to extensibility - code sharing relies on modularity
  \item Modules force developers to think of, and implement interfaces
  \item Modularity lends itself to PoLP: modules don't need access to everything
\end{itemize}

Explaining PoLP.
\begin{itemize}
  \item Principle of Least Privilege recommends that principals only have
        the minimal access (do data or other resources) required to perform
        their functionality
  \item Implies complicated programs should be further decomposed
  \item Modularity simplifies decomposition, we already have logical parts
  \item PoLP extends to compartments within a program.
  \item PoLP should be temporal too (privileges last only as long as required)
  \item PoLP helps mitigate bugs. A bug is not able to access as much data or stuff.
  \item PoLP forces interfaces, and enables checks at these interfaces
\end{itemize}

\subsection{Isolation and Communication}

A program cannot execute entirely with isolated compartments.
Compartments need to coordinate to get the job done, i.e., compartments need
to request work from other compartments.

Compartments have interfaces, from which other compartments can request work.
This means there will be control flow between compartments.

For improved security, compartmentalization requires isolation of resources.
Typically, this requires - 
\begin{itemize}
  \item Isolation in memory. Memory access needs to be restricted according to
        the policy. This allows compartments to have private data, or to
        share data between a specific set of compartments.
  \item Isolation in control flow. Restrictions on which compartment can call
        which other compartment. 
        For example, sandboxed code should only be able to call into the
        runtime compartment, not directly other sandboxes or to supervisor.
  \item Isolation in system resources, such as file descriptors, semaphores
        and threads. 
        Particularly useful in Linux, where all resources are described as
        files, and file descriptors are used ubiquitously for system resources.

\end{itemize}

\subsection{Survey of use cases}

Who could use compartmentalization?

What would they benefit from this, security and performance wise?

\subsection{Security Properties from Compartmentalization}
This subsection will describe the security benefits of compartmentalization. This subsection should explain exactly what attack scenarios are protected and which ones are not. At the end of this section, the reader should be clear about what the security guarantees of compartmentalization are. Particularly, we should be clear that compartmentalization does not protect against buggy modules that allow compromise via their external interface.

We will also discuss how specific protections can be provided by mechanisms, and
why they each matter.

For example, why does lack of code-checks in MPK matter?

Why does the lack of exclusive access matter?

\subsection{Performance Properties from Compartmentalization}

What sort of actions do we expect from compartmentalization?

What is their frequency?

How do these affect the performance of the complete program?


\section{Points of Classification/metrics}

Take from google doc

\subsection{Access Control Permissions}

Compartments are under access control. 

First, data accesses need to be checked. 
Otherwise, an attacker can compromise a compartment to directly access another
compartment's data.
Second, an attacker can "inject" fake data in their own compartment, and 
manipulate the victim to access it (maybe confusing this data for their own).
With data checks, the second step will fail even if the first succeeds.

Instruction accesses need to be checked, without which three are a 
couple (? maybe only one) of different attack vectors.
First, code injection becomes simplified without instruction access checks.
An attacker can inject malicious code in their own compartment, then needs
to influence the victim to execute that code (leveraging some existing bug).
With instruction checks, the second step will fault, even if the first step
succeeds.
Second, data can be held in executable sections, encoded in instructions for example.
Imagine a JavaScript sandbox whose code is generated on the fly. 
The existence/lack of particular code can indicate particular JavaScript which has
been executed, and thereby linked back to specific secrets in JavaScript.
Cross-sandbox code execution can, therefore, leak data through this side channel.

Processes implement both data and code access checks. 
Further, each process decides what data/files get mapped into their address space.
However, this can also lead to problems where a process can map a file without
consent (refer to a separate subsection).

XPC and lwc are based on process-like abstractions, and both have proper
code and data access control.

MPK implements data checks, but lacks code checks. 
This is likely motivated by performance reasons/ease of implementation.
ERIM and libmpk, which build on MPK also lacks code access checks.
Donky, which is inspired by MPK, also lacks code checks.

CHERI compartmentalization requires capabilities for code execution and
data access. Satisfactory security.

CODOMs link code to compartments, and has no code sharing.
Implicitly has code access control.
Also has data checks.

MMP has both code and data access control.

\subsection{Intra compartment call gates}

Compartments typically implement separate functionality, and
need to coordinate to achieve the program's desired functionality.
Programs will have some compartment call another compartment to
do some processing.
When compartments interact, 
\begin{itemize}
      \item Compartments must implement checks to secure the interface:
            Arguments must be checked, caller-callee pair must be
            allowed.
            Other restrictions might apply, based on application.
      \item Checks can be in hardware or software, or a mix of both.
            Common checks can be in hardware, software allows 
            application-specific checks.
      \item Should not be possible to elide checks.
\end{itemize}
To assure the above, inter-compartment control flow must follow call gates
which implement the requisite checks.
Call gates must be entered at the start, to prevent ROP-style attacks.

Suppose a compartment starts with argument validation and then proceeds to
using the arguments, lack of call gates can allow an attacker to run the 
compartment directly with invalid arguments by entering just after the
checks.

Migrating threads can similarly cause issues if an attacker calls a victim
with malicious register state.
An attacker might, for example, force a victim to execute with an illegal,
attacker-crafted stack.

Execution following a call-gate entry must stay secure, specially if using
migrating thread model where the execution continues with the caller's 
context.
Migrating thread model is insecure in the general case. 
Can be made secure through formal checks on code (possible for small code)
or through adaptation into static threading through the addition of context
switching.

Requirements are:
- checked entry point(s)
- secure execution/secure context switch.

Processes have secure entry points, and use static threading.
Kernel system call return points following IPC wait calls are implicit
entry points. 
Callers cannot enter at arbitrary address.
Kernel also maintains thread context during system call, so context is
restored before system call returns.

XPC maintains the same model as processes, but maintains entry points/call
stacks in hardware.
Also maintains state, maybe.

MPK lacks call gates. 
PKRU value can be changed any time, but no intra-address space control-flow
guards are provided.
MPK also lacks explicit tracking of executing compartment.
Therefore, no way to distinguish whether context is correct/switch to correct
context.
libmpk adds nothing more.

ERIM adds call gates to MPK.
Call gates cannot be bypassed, therefore control flow attacks become impossible.
However, big performance penalty.

Donky adds the pseudo-privileged library to protection keys.
Similar to processes, this maintains control flow integrity and entry points.
(Gotto check) Donky reverts to static threading.

CHERI also relies on the supervisor, and provides both checked entry points
and contexts.

SecureCells has lightweight inter-compartment entry checks.
Static threading can be implemented on this base.

CODOMs does not have call gates. 
Any jump will implicitly switch compartments based on the source and target
instruction pointers.

\subsection{Zero Copy data movement}

When compartments communicate, they also send data across the interface.
A common framework for data transfer between processes uses protobufs
to serialize data (aggregate data from different data structures into
a serial form), copy data via a system call (likely sendmsg for Linux),
and deserialize the information at the receiver.

The Communication interface also comes with a potential security
issue.
If a compartment can unilaterally inject permission to code or data
into another compartment, that can lead to confused deputy attacks where
the target uses the transferred information under the confusion that the
data is its own. 

While the RPC framework is flexible, it suffers from limited performance.
In specific cases, systems can benefit from moving permissions to memory
instead of copying the data over.
This advantage becomes more pronounced for larger data movements.
In particular cases, zero-copy data transfer offer the sole practical
opportunity to satisfy strong performance requirements. 
Key example is networking functions.
However, the RPC interface is also secure. 
The receiver of the RPC must explicitly use a syscall to accept an 
incoming RPC.
Further, incoming RPCs necessarily appear as data, not code.

A trade-off for zero-copy data movement is that the involved data needs
to be serialized, and programs that naturally deal with serialized buffers
profit with ease.

CHERI's capability model offers a natural fit to zero-copy permissions 
transfers, as access to a buffer passes along with the pointer when passed
as cross-compartment capability arguments along with all contained 
capabilities.
A single capability argument can grant access to a complex data structure
across multiple regions, alleviating the need for serialization.
This power, however, must be used with care.
If any unwanted capability is leaked, anywhere within the nested structures,
CHERI can be compromised.
CHERI's capabilities also resemble unilateral information transfers.

XPC offers hardware support for zero-copy transfer for one segment, which can
be subsequently monotonically shrunk in nested RPC calls.
Great for performance, but limited use cases: only those programs which can
be shoehorned into this shell.
XPC's information injection is also restricted to data, but is unilateral.

Protection key-based methods (MPK/libmpk/ERIM) can offer zero-copy permission
transfer to all pages with the same color, simply by writing the correct
permissions to the target compartment's key.
However, this is all or nothing.
Protection keys give very little protection against injection of code/data.

SecureCells allows zero-copy permission movement. 
Crucially, 
\begin{itemize}
      \item transfers require a handshake
      \item it allows unlimited segments to be moved
\end{itemize}
However, all or nothing: entire cell gets transferred.
SecureCells does not support efficient shrinking of data regions.

\subsection{Flexibility/Generic support}
\atri{A lot of stuff here seems wishy-washy. Not convincing.}

Flexibility in a mechanism will allow it to be used with a variety of
use cases/applications.

For example, can a mechanism support the large degree of code sharing
within modern programs?
Can a mechanism support a non-hierarchical trust relation between
compartments?

Mechanisms which specialize for sandboxing will not be able to
support mutually distrusting compartments without intervention via a
trusted runtime compartment.
\atri{give examples} (IMIX, ERIM, MemSentry)

CODOM identifies a compartment by its program counter, i.e. code has a
1:1 link with compartment.
For example, multiple JavaScript sandboxes will not be able to share
a library for, say, cryptographic operations.
In such a case, a common design might be to isolate different
cryptographic contexts corresponding to different compartments, but
share the library code which operates on those contexts.

Mechanisms which can configure which protections are used can offer a
security-performance trade off where justified.
Using Mach's migrating thread model might be good.

While Linux' process model semantics are nigh impossible to change, due to
a large focus on not breaking userspace, many operations are implemented
in software and allow change.
Cloud providers, or other users, can modify Linux, and make changes which
improve performance. 
Light-weight contexts follows this principle (based on FreeBSD, not Linux).
Other uses include fast IPC models. 
Only the system call entry and return, and use of privileged instructions
for changing address spaces, rely on hardware and cannot be elided.

CHERI implements its own supervisor, relying on a few key privileged
operations to seal and unseal encapsulated capabilities.
Remaining stuff may be customizable?

XPC would support existing applications using RPC. 
However, nothing can be added or removed, since the entire abstraction
is implemented in hardware and centred around today's (g)RPC interface.
XPC limits the sharing segment to a single instance.

LOTRx86 and HODOR rely on specific implementations of Intel's
extensions to x86. 
These mechanisms cannot be later run on other architectures, like
ARM or RISC-V.

SecureCells offers a little bit of flexibility with context switching.
However, the PTable is quite open.
SecureCells does not depend on architecture-specific features.
However, SecureCells mixes protection and translation near the core,
and requires segment-like allocation of physical memory for virtual
memory ranges.

% \subsection{Backward compatibility}
