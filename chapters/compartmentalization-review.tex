Compartmentalization brings security benefits to programs, and can reduce the
costs of other programs.

Compartmentalization can be implemented on various mechanisms.

These mechanisms can lead to varying degrees of isolation and performance.

A survey of compartmentalization mechanisms is required to understand the
properties and guarantees of different proposals.

Deep dive into different features.


\section{Background on Compartmentalization}

\begin{itemize}
      \item Modern software is monolithic, or compartmentalized at a coarse granularity.
      \item Monolithic software runs all parts of an application in a single address space
      \item Issues with monolithic software includes:
            Memory safety bugs can compromise data throughout the address space
            Control flow hijack/bending allows any code to call any other code
            Can lead to system calls being called from unexpected code
\end{itemize}

In contrast, a compartmentalized program separates logical components of the application
and isolates them in individual compartments, which implies some degree of separation.
Isolation restricts which resources each compartment has access to, in order to prevent
one or more of the above attack vectors.

COmpartments are logical, and not necesesarily linked to code. 
For example, compartments for a browser can include the JIT compiler, the runtime and the
untrusted sandbox code. 
While these are isolated, they may have access to the same code, including libraries like
libc.
Additionally, there might be one or more sandboxes which are instances of the same module,
for example, and thereby share exactly the same code regions. 
However, they would need to have separate data regions or some isolated contexts.
All of this is to say that we should not make a 1:1 link between code and compartment.

The aim of this section is to provide background of compartmentalization as a software design principle to provide enhanced security. This section will explain the terminology of "monolithic" and "compartmentalized" programs. This section will also describe the attacker model for compartmentalization and what attacks can be prevented.

\subsection{Modularity and Principle of Least Privilege}
Explaining modularity.
\begin{itemize}
  \item Modularity is a key principle in modern software design
  \item Modularity helps handle exploding code complexity, simplifies design
  \item Modules are clustered around separate functionality
  \item Modularity lends itself to extensibility - code sharing relies on modularity
  \item Modules force developers to think of, and implement interfaces
  \item Modularity lends itself to PoLP: modules don't need access to everything
\end{itemize}

Explaining PoLP.
\begin{itemize}
  \item Principle of Least Privilege recommends that principals only have
        the minimal access (do data or other resources) required to perform
        their functionality
  \item Implies complicated programs should be further decomposed
  \item Modularity simplifies decomposition, we already have logical parts
  \item PoLP extends to compartments within a program.
  \item PoLP should be temporal too (privileges last only as long as required)
  \item PoLP helps mitigate bugs. A bug is not able to access as much data or stuff.
  \item PoLP forces interfaces, and enables checks at these interfaces
\end{itemize}

\subsection{Isolation and Communication}

A program cannot execute entirely with isolated compartments.
Compartments need to coordinate to get the job done, i.e., compartments need
to request work from other compartments.

Compartments have interfaces, from which other compartments can request work.
This means there will be control flow between compartments.

For improved security, compartmentalization requires isolation of resources.
Typically, this requires - 
\begin{itemize}
  \item Isolation in memory. Memory access needs to be restricted according to
        the policy. This allows compartments to have private data, or to
        share data between a specific set of compartments.
  \item Isolation in control flow. Restrictions on which compartment can call
        which other compartment. 
        For example, sandboxed code should only be able to call into the
        runtime compartment, not directly other sandboxes or to supervisor.
  \item Isolation in system resources, such as file descriptors, semaphores
        and threads. 
        Particularly useful in Linux, where all resources are described as
        files, and file descriptors are used ubiquitously for system resources.

\end{itemize}

\subsection{Survey of use cases}

Who could use compartmentalization?

What would they benefit from this, security and performance wise?

\subsection{Security Properties from Compartmentalization}
This subsection will describe the security benefits of compartmentalization. This subsection should explain exactly what attack scenarios are protected and which ones are not. At the end of this section, the reader should be clear about what the security guarantees of compartmentalization are. Particularly, we should be clear that compartmentalization does not protect against buggy modules that allow compromise via their external interface.

We will also discuss how specific protections can be provided by mechanisms, and
why they each matter.

For example, why does lack of code-checks in MPK matter?

Why does the lack of exclusive access matter?

\subsection{Performance Properties from Compartmentalization}

What sort of actions do we expect from compartmentalization?

What is their frequency?

How do these affect the performance of the complete program?


\section{Points of Classification/metrics}

Take from google doc

\subsection{Access Control Permissions}

Compartments are under access control. 

First, data accesses need to be checked. 
Otherwise, an attacker can compromise a compartment to directly access another
compartment's data.
Second, an attacker can "inject" fake data in their own compartment, and 
manipulate the victim to access it (maybe confusing this data for their own).
With data checks, the second step will fail even if the first succeeds.

Instruction accesses need to be checked, without which three are a 
couple (? maybe only one) of different attack vectors.
First, code injection becomes simplified without instruction access checks.
An attacker can inject malicious code in their own compartment, then needs
to influence the victim to execute that code (leveraging some existing bug).
With instruction checks, the second step will fault, even if the first step
succeeds.
Second, data can be held in executable sections, encoded in instructions for example.
Imagine a JavaScript sandbox whose code is generated on the fly. 
The existence/lack of particular code can indicate particular JavaScript which has
been executed, and thereby linked back to specific secrets in JavaScript.
Cross-sandbox code execution can, therefore, leak data through this side channel.

Processes implement both data and code access checks. 
Further, each process decides what data/files get mapped into their address space.
However, this can also lead to problems where a process can map a file without
consent (refer to a separate subsection).

XPC and lwc are based on process-like abstractions, and both have proper
code and data access control.

MPK implements data checks, but lacks code checks. 
This is likely motivated by performance reasons/ease of implementation.
ERIM and libmpk, which build on MPK also lacks code access checks.
Donky, which is inspired by MPK, also lacks code checks.

CHERI compartmentalization requires capabilities for code execution and
data access. Satisfactory security.

CODOMs link code to compartments, and has no code sharing.
Implicitly has code access control.
Also has data checks.

MMP has both code and data access control.

\subsection{Intra compartment call gates}

Compartments typically implement separate functionality, and
need to coordinate to achieve the program's desired functionality.
Programs will have some compartment call another compartment to
do some processing.
When compartments interact, 
\begin{itemize}
      \item Compartments must implement checks to secure the interface:
            Arguments must be checked, caller-callee pair must be
            allowed.
            Other restrictions might apply, based on application.
      \item Checks can be in hardware or software, or a mix of both.
            Common checks can be in hardware, software allows 
            application-specific checks.
      \item Should not be possible to elide checks.
\end{itemize}
To assure the above, inter-compartment control flow must follow call gates
which implement the requisite checks.
Call gates must be entered at the start, to prevent ROP-style attacks.

Suppose a compartment starts with argument validation and then proceeds to
using the arguments, lack of call gates can allow an attacker to run the 
compartment directly with invalid arguments by entering just after the
checks.

Migrating threads can similarly cause issues if an attacker calls a victim
with malicious register state.
An attacker might, for example, force a victim to execute with an illegal,
attacker-crafted stack.

Execution following a call-gate entry must stay secure, specially if using
migrating thread model where the execution continues with the caller's 
context.
Migrating thread model is insecure in the general case. 
Can be made secure through formal checks on code (possible for small code)
or through adaptation into static threading through the addition of context
switching.

Requirements are:
- checked entry point(s)
- secure execution/secure context switch.

Processes have secure entry points, and use static threading.
Kernel system call return points following IPC wait calls are implicit
entry points. 
Callers cannot enter at arbitrary address.
Kernel also maintains thread context during system call, so context is
restored before system call returns.

XPC maintains the same model as processes, but maintains entry points/call
stacks in hardware.
Also maintains state, maybe.

MPK lacks call gates. 
PKRU value can be changed any time, but no intra-address space control-flow
guards are provided.
MPK also lacks explicit tracking of executing compartment.
Therefore, no way to distinguish whether context is correct/switch to correct
context.
libmpk adds nothing more.

ERIM adds call gates to MPK.
Call gates cannot be bypassed, therefore control flow attacks become impossible.
However, big performance penalty.

Donky adds the pseudo-privileged library to protection keys.
Similar to processes, this maintains control flow integrity and entry points.
(Gotto check) Donky reverts to static threading.

CHERI also relies on the supervisor, and provides both checked entry points
and contexts.

SecureCells has lightweight inter-compartment entry checks.
Static threading can be implemented on this base.

CODOMs does not have call gates. 
Any jump will implicitly switch compartments based on the source and target
instruction pointers.
