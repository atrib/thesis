%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%

The operating system (OS) kernel provides isolation between processes and is
a key trusted computing
base. Each \emph{untrusted} userspace process runs under a
dedicated user in its own address space and must request resources (such as
communication channels or changes to its address space) from the \emph{trusted}
kernel. The userspace/kernel interface forms an explicit trust barrier;
all data that crosses this boundary in either direction must be carefully
checked by the kernel.
%
Userspace processes attack the kernel by issuing system calls (syscalls) that then trigger
kernel bugs, elevating the privileges of the process.
%
A common class of kernel bugs are so-called \emph{double-fetch}
bugs~\cite{serna08doublefetch, twizsgrakky07ring0, wilhelm2016xenpwn,
wang2018survey}. They occur when higher-privileged code, such as
the kernel, reads the same data from the lower-privileged address space twice.
%
Double-fetch bugs are a
\emph{race condition} between threads of different privileges. A
\emph{time-of-check to time-of-use (\tocttou)} violation occurs when the first
read is used to check a condition while the second read is used to modify
state.
%
An example of a double fetch bug is when the kernel reads the length of a buffer
from userspace, allocates a kernel buffer, then reads the length a second time
to finally copy the data from userspace to the kernel. An attacker may concurrently
overwrite the length of the buffer (with a larger number) after allocation,
causing the memory copy to overflow the kernel buffer.
%
Double-fetch bugs are a frequent problem in kernels and
hypervisors~\cite{cve201812633, cve202012652, cve20131332, cve201920610,
cve20158550, cve201610439, cve201610435, cve201610433, cve20195519,
cve20168438}.
% Considering that double-fetches also appear in drivers, legacy
% systems with binary-only drivers cannot be patched, even if a bug is found.
Watson~\cite{watson2007exploiting} blames an unfixable \tocttou
constellation as a reason for the generic insecurity of \emph{syscall
wrappers}.
Syscall filtering wrappers require that data read from userspace for the
initial check remains the same when the kernel later uses it for computation.
Therefore, such filters can currently only check arguments passed by value.
\midas enables ``deep argument inspection'' for SecComp~\cite{seccomp_deep, seccomp}
(i.e., checks arguments passed by reference).
Without \midas, such inspection is impossible: these checks
introduce double fetches, and consequently \tocttou bugs.

To mitigate double-fetch bugs in the kernel, a system must prohibit
\emph{concurrent changes}\footnotemark to memory accessed by the syscall. Attackers may
find crafty ways to trigger such concurrent writes, including:
\begin{inparaenum}[\itshape i\upshape)]
\item  direct writes from userspace (e.g., from concurrent threads),
\item  kernel writes from syscalls (e.g., from concurrent syscalls),
\item  modifying address space mappings,
\item  concurrent \texttt{write} syscalls to a file that alters mapped
file pages, and
\item  storing arguments on device-backed pages, leveraging devices to trigger
concurrent writes.
\end{inparaenum}
To prevent attacks, all concurrent writes must be prohibited.
\footnotetext{The attacker model includes both concurrent and parallel
writes. For readability, this chapter refers to both writes as ``concurrent''.}

% TODO key idea
\begin{center}
  \textbf{\emph{``Through a syscall's lifetime, every read to a userspace object
  will return the same value.''}}
\end{center}
We base our defense on one key invariant, stated above. 
From this invariant we derive a \emph{security
property} ensuring that every read during the execution of a syscall is
tracked. Subsequent reads from the same address will always return the same value.
For performance, multiple versions of an object may exist simultaneously,
depending on when the syscall was started and how many
concurrent syscalls are in flight. 
Orthogonally, we derive a \emph{correctness
property} that ensures the sharing of the correct version among inflight
syscalls. All writes end up on the most recent version of
the objects, allowing forward progress.
While we implement this invariant in our \midas prototype for the Linux kernel,
this defense applies to any modern OS kernel.

Our evaluation of \midas demonstrates low performance overhead.
On workloads from the NAS Parallel Benchmarks suite, \midas shows
an average performance overhead of~$3.7\%$. Similarly, its performance overhead on
more kernel-intensive workloads from the Phoronix Test Suite is~$3.4\%$ (with
negligible memory overhead).
%
Our security evaluation demonstrates how \midas successfully stops all attacks
against vulnerable syscalls.
%
Our contributions are:

\begin{itemize}
\item Distillation of \tocttou attack vectors into an invariant that protects
the kernel against malicious concurrent modifications,
\item \midas, a design that prohibits and detects
\tocttou attacks against modern kernels, prohibiting their exploitation,
enabling developers to detect \tocttou bugs, and providing the foundation for
safe syscall interposition and validation, and
\item An efficient implementation of \midas for the Linux kernel that exhibits
low ($3.4\%$) performance overhead.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%
\section{Background}
%%%%%%%%%%%%%%%%%%%%

\midas orchestrates several mechanisms within the Linux memory subsystem
to provide its protection guarantees.
Linux uses architecturally defined per-address space page tables to define
mappings to pages.
\midas protects these pages by temporarily marking them read-only in the
page tables.
This section provides background information necessary to reason about
why and how \midas protects syscalls from concurrent writes.


\subsection{Page Tables and Memory Protection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Virtually all contemporary architectures (e.g., x86, ARM, SPARC, and
RISC-V) implement separate virtual and physical
address spaces (AS) based on fixed-size regions called pages.
Programs execute in their virtual address space while caches and main memory
are accessed with physical addresses.
Architectures rely on page tables orchestrated by the operating system
to translate between these address spaces and to protect memory accesses.
Page tables are arranged as radix trees, where different bits of the
virtual address are used as indices into successive levels of the page table.
At the leaf page table, a unique pagetable entry (PTE) stores the
translation and protection information for a page.

A PTE in x86-64 is a 64-bit value holding, among others, the following metadata:
% \begin{description}[noitemsep]
%   \item[Present bit (P)] which marks the PTE's validity;
%   \item[Protection bits (NX, R/W, U/S)] which restrict the type of
%         access and the privilege level of the accessing code;
%   \item[Software-usable bits] (SW1-SW4) ignored by the MMU and used by the
%         operating system to store metadata;
%   \item[Page Frame Number (PFN)] identifying the page's physical address.
% \end{description}
a \emph{Present bit (P)} to mark the PTE's validity;
\emph{Protection bits (NX, R/W, U/S)} to restrict the type of
access and the privilege level of the accessing code;
\emph{Software-usable bits (SW1-SW4)} that are ignored by the MMU and used by 
the operating system to store metadata; and
a \emph{Page Frame Number (PFN)} to identify the page's physical address.
The \emph{U/S} separates kernel (supervisor) pages from user pages.
The \emph{R/W} controls whether pages are writable or not.

An access using a virtual address first reads the corresponding PTE's
present bit to check its validity.
Then, the access checks whether the access is allowed from the executing
code's privilege level by checking the U/S bit and whether the
read/write access is allowed by checking the R/W bit.
When all checks pass, the processor uses the PFN to find the data in
the caches or in memory.
When a check fails, the processor raises a protection fault/exception and
moves control to an OS-specified exception handler.

Reading PTEs from a multi-level page table is an expensive operation, and
modern processors cache PTEs in caches known as Translation Lookaside
Buffers (TLBs) to reduce the cost of subsequent accesses.
On most architectures, the OS is responsible for keeping TLBs coherent with
the page table, necessitating entries to be flushed from TLBs when the
corresponding PTE is updated.
Modern multiprocessing CPUs have a TLB for each core, and PTE information
may be cached in one or more TLBs.
Therefore, when the OS changes a PTE value, the OS is also responsible for
flushing remote TLBs (i.e., on another cores) as required.
Commercial-off-the-shelf systems typically rely on an inter-process 
interrupt (IPI) to the OS running on a remote core followed by a local TLB 
invalidation.
Due to the scalability limitations of broadcasting IPIs to remote cores, 
the TLB invalidation process is highly optimized in software, and has
received dedicated hardware support in more recent processors and in research
proposals.\atri{cite, ask yuanlong}

\subsection{Linux Memory Subsystem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Linux implements various abstractions---including processes, files, and shared
memory---using the architecture's page tables.
All threads within a Linux process share a single address space, and
consequently use the same page table for translation and protection.
Each page within the process' virtual address space may be mapped or
unmapped. 
Mapped pages have separate read/write/execute permissions.
Programs typically have write-execute exclusion, meaning
code pages cannot be written to and data pages cannot be executed.
These permissions map directly to page-table bits.
Pages in Linux may also be copy-on-write (COW) pages, which are mapped 
read-only in multiple address spaces, but duplicated when any process writes
to it, resulting in a separate copy.

Linux maintains userspace and kernel mappings to memory in distinct
parts of the virtual address space.
The PTE entries for kernel mappings, located in the top half of the
address space, have the $U/S$ bit set.
These kernel mappings are identical for all address spaces, and are
kept consistent across the corresponding page tables.
In contrast, the PTE entries for userpace mappings, located in the 
bottom half of the address space, have the $U/S$ bit reset.
A userspace page has atleast one userspace mapping and atleast one
kernel mapping.
Shared userspace memory is implemented by mapping a page in more than
one address space.

Files in Linux occupy a separate namespace (rooted at \Code{/}).
However, when files are read or written, parts of the file are cached
in the kernel's page cache (which consists of pages mapped in the kernel's
address space).
Moreover, programs can explicitly map pages from a file, in which case
the corresponding pages from the page cache are also mapped at userspace
addresses in the process' page table.
Mapped file pages can therefore be accessed by the file-system driver using
kernel addresses, and userspace programs using userspace addresses.
Userspace pages not backed by a file are called \emph{anonymous pages}.

Processes in Linux can also share memory pages, which might be set up
implicitly by memory mapping pages from the same files, or explicitly
through named shared memory objects.
The same physical page might be mapped in two or more processes'
virtual address spaces, and be accessible through the respective
virtual addresses in each process.
Linux maintains a reverse map for each physical page mapped to user virtual
memory, linking from the pages' metadata to the PTEs for each mapping.
Reverse mappings enable \midas to precisely and efficiently identify all 
possible addresses that may be used to modify the contents of an user page.


\subsection{Supervisor Memory Protection} %  and user-copy interfaces}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Kernel accesses to userspace memory use userspace mappings, introducing
the risk of the kernel confusing userspace data structures
for kernel data structures.
An attacker can exploit this behavior via bugs in the
kernel.
Essentially, the attacker needs to set up either data structures
or code within its accessible memory, then exploit a kernel
bug to make the kernel use these data structures, or execute
this code.
This class of attacks is known as confused-deputy attacks, since the
privileged softare (kernel) tasked with isolating userspace processes
confuses its own code/data with the user's.

Architectures and OSs have mitigated these vulnerabilities
by introducing \emph{supervisor memory protection}.
Under supervisor memory protection, kernel read/write/execute access to 
userspace memory raises a fault (depending on the state of a per-core system
register).
On x86-64, these features are known as Supervisor Memory Access
Protection (SMAP) for data accesses, and Supervisor Memory Execution
Protection (SMEP) for code accesses. 
Bits in the CR4 register track whether these protections are active, 
and the privileged \Code{stac}/\Code{clac} instructions are used to 
quickly enable and disable SMAP.
In the OS, all accesses to userspace memory are made explicit,
using \emph{transfer functions} to read from and write to userspace memory.
Any unintended access outside of these functions causes a
hardware fault, indicating a kernel bug or an attack.
Linux implements the \Code{copy_\{from/to\}_user} functions, which
use the access control instructions to disable SMAP before
accessing userspace data, and then re-enable SMAP afterwards.  
Transfer functions make
kernel accesses to userspace data explicit, allowing
\midas to reliably track and protect \emph{every} kernel fetches 
from userspace memory.

\subsection{Double-Fetch Bugs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[]
  \centering
  \includegraphics[width=.6\linewidth]{media/midas/doublefetch.pdf}
  \caption{Example of a double-fetch bug.}
  \label{fig:midas:doublefetch}
\end{figure}

Double-fetch bugs occur when a privileged environment (such as the kernel)
reads untrusted memory multiple times, returning different values each time.
Such a situation is depicted in \autoref{fig:midas:doublefetch}, 
where the value of \Code{X} in memory is changed by an attacker
between two reads by the target thread.
Exploiting such a bug requires a race condition i.e. accesses 
to memory in a particular order across threads.
A specific variety is the \emph{time-of-check to time-of-use}~(\tocttou) 
bug which occurs when the first fetch validates an object's value and
the second fetch uses the same object's value.
\tocttou bugs are widely studied in file systems, where the
API makes it possible to swap the file after validating the access
rights~\cite{payer2012protecting,
pu2006methodical, wei2010modeling, tsafrir2008portably,Garfinkel03}.
\tocttou bugs affect both kernel~\cite{jurczyk2013bochspwn, wang2018survey}
and dynamically-loaded driver code~\cite{cve201812633,cve201812633fix}.
Wang et al.~\cite{wang2018survey} showed that double fetches appear not only
in kernels, but wherever there is a trust boundary to cross (e.g.,
kernel---hypervisor~\cite{wilhelm2016xenpwn} and hardware---kernel
boundaries~\cite{lu2018untrusted}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Attack vectors}
%\label{sec:midas:threats}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

% In this section, we describe the threat model for exploiting double-fetch
% bugs in the kernel and classify the possible attacks based on how the
% data is modified between vulnerable double fetches.

\section{Threat Model}
\label{sec:midas:threatmodel}
%%%%%%%%%%%%%%%%%%%%%%%%%

% Nothing fancy -- the adversary is just trying to hack the system
% No black magic allowed
The attacker has access to a user account on the target machine. 
They can execute arbitrary userspace code, including syscalls. 
Some of the system calls have double-fetch vulnerabilities which the attacker 
wishes to exploit (e.g., for privilege escalation).
The attacker may execute arbitrary sequences of syscalls on multiple CPU
cores in parallel, or concurrently on the same core.
However, the attacker is not allowed direct access to devices, as only the
privileged root user is permitted this capability.

\midas mitigates any unintended corruption or information leakage \emph{in the kernel}
or \emph{in other user processes} that arises through double-fetch bugs.
Hardware attacks such as Rowhammer~\cite{mutlu2019rowhammer}
or side-channels~\cite{KocherHFGGHHLM019}, and file-system TOCTTOU
attacks~\cite{payer2012protecting, pu2006methodical, wei2010modeling,
tsafrir2008portably} are out of scope.


\section{Attack Classification}
\label{sec:midas:attacks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{table}
  \centering
    \begin{tabular}{ !l | ?l | ?l | ?l }
  \toprule
      \rowstyle{\bfseries}
      & Userspace    & Kernel                & Device \\ \midrule

      % Note: this is a manually tuned fixup. multirow just sucks.
      & Intra AS     & User mapping          & DMA       \\
      \multirow{-2}{*}{\shortstack[l]{\textbf{Existing} \\ \textbf{mapping}}}
      & Cross AS     & Kernel mapping        & MMIO page     \\
      \midrule

      & \Code{mmap}  & \Code{mm\_populate}   & New           \\
      & \Code{clone} &                       & DMA/     \\
      \multirow{-3}{*}{\shortstack[l]{\textbf{New} \\ \textbf{mapping}}}
      & \Code{swap}  &                       & MMIO page              \\
  \bottomrule
  \end{tabular}
  \caption{Attack vector classification for \tocttou exploits.}
  \label{tab:midas:attack_class}
\end{table}

\midas guards data processed during a syscall's execution against concurrent 
modification.
We label the data fetched twice as vulnerable data.
In this section, we classify attacks based on two criteria: the
privilege level of the writer, and whether the mapping used for writing
exists at the time of the first read. 
\autoref{tab:midas:attack_class} summarizes our classification.
Importantly, this classification helps understand existing attacks and how to
protect against them, and where future attacks (bugs) may arise.
The device column corresponds to attacks where a device
(e.g., a network card, GPU, FPGA) is responsible for modifying vulnerable data.
Watson~\cite{watson2007exploiting} describes a subset of the
following attack vectors.

Existing userspace mappings to a page can be used to modify
vulnerable data which the targeted syscall is reading.
Userspace can directly write to a mapped page, irrespective of whether the 
mapping is in the same address space or not.
% Watson~\cite{watson2007exploiting} called such attacks
% \emph{direct double fetch} attacks.
Alternatively, a concurrently executing syscall can also modify the
vulnerable data in a \emph{confused-deputy} attack.
When the attacker passes a pointer to the vulnerable data to
the syscall as a user buffer in which the syscall can return some
data, the kernel's write to the buffer can modify vulnerable data.
For example, the \Code{read} syscall takes an argument pointing
to a user buffer where the contents of a file will be copied to.
Another example is \Code{rt_sigaction}, where the kernel writes to
a user buffer pointed to by the \Code{oldact} argument.
In both of these attacks, the malicious write uses a userspace
mapping.
\emph{A protection mechanism must account for all userspace
mappings to pages containing vulnerable data at the time of the
targeted syscall's first read.}

Existing kernel mappings to a page also mapped in userspace can be
leveraged by an attacker in a confused-deputy attack.
Here, the attacker maps a file-backed page from the page cache into a
userspace process and then passes as an argument in this page to the
target syscall.
The attacker then triggers a concurrent \Code{write} syscall to modify the
vulnerable data using kernel mappings for the page cache pages.
% This attack is called \emph{inception double fetch}~\cite{watson2007exploiting}.
% \mat{Did we call it inception double fetch?}
The kernel does not explicitly track kernel addresses mapping to a page,
but the file-system driver does explicitly find the page before writing to it.
\emph{A protection mechanism must instrument file-system
drivers to account for writes via kernel mappings to vulnerable data.}

The kernel might create new mappings to the vulnerable data
between the double fetches by the target syscall, bypassing any 
protective permissions installed by the transfer function in 
PTEs at the time of first read.
An attacker can call \Code{mmap} and \Code{clone} to create
a new mapping to the vulnerable data before writing to it.
% The first version is called a \emph{reflected double fetch}
% attack~\cite{watson2007exploiting}.
The page-table mapping might not be created at the time of the malicious
syscall, but lazily when the attacker writes to the vulnerable data
due to demand paging.
In a more involved variant, the attacker can use the kernel as a
confused deputy which touches the unmapped page and maps it in,
then writes to the vulnerable data.
In all of the above vectors, the function populating pages for a
process (\Code{mm_populate} on Linux) is creating the new mapping.
\emph{A protection mechanism must instrument any syscalls
and other kernel mechanisms which can create new mappings.}

Swapping may also create a new page-mapping.
If the attacker writes to a page that was previously swapped
to disk, but later swapped in to be read by the target syscall in
a different address space, the kernel might lazily reinstate
the attacker's mapping to the page.
\emph{The swapping mechanism must be protected.}

\midas protects against all of the previously-listed attack vectors.
In the absence of any other syscall which can create new userspace
mappings to vulnerable data, \midas' protection is complete
against writes from both user and kernel code.

Finally, a device might modify vulnerable data if it is either
allowed to DMA (direct memory access) to the page, or if the page is memory 
mapped (MMIO) and is actually backed by the device.
In the latter case, external factors can change the vulnerable data.
Existing discretionary access control rules typically prevent users
(except a superuser) from mapping device-backed pages into their
address spaces.
Such users are also disallowed from configuring DMA devices.
Thus, device modifications to vulnerable data fall outside
our threat model and are not protected by \midas.
% The superuser may load arbitrary kernel code % via loadable
% % modules
% and confused-deputy attacks leveraging an incompetent
% system administrator are also outside the purview of our threat model.
However, \midas can be extended to protect against modifications by DMA devices
on processors supporting IOMMUs or similar methods for
access control~\cite{olsonbordercontrol}.
As a superuser can modify kernel code via kernel modules, protecting against 
attacks from this user falls outside of our threat model.


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\midas Design}
\label{sec:midas:midas:design}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\midas maintains a single, core, \emph{invariant}:
\textbf{\emph{through a syscall's lifetime, every read to a userspace object
will return the same value}}.
By construction, the invariant guarantees that double-fetches in syscall
code will read the same data, \emph{eliminating \tocttou bugs}.
\midas maintains the invariant by tracking \emph{snapshots} of objects
when first accessed, lazily making \emph{copies} when the object is concurrently
written and accessing the correct copy on subsequent reads.
Copies are only maintained during syscalls' lifetimes, and are released as
soon as no syscall needs it.
Consequently, each userspace object has a single copy when no syscalls are
running.
The invariant also means that only accesses to userspace objects by the kernel
need to be protected.
Accesses to userspace objects from userspace and kernel objects by kernel
code remains unaffected.

\midas' implementation builds on the protection mechanisms provided by
existing virtual memory implementations.
On modern platforms, virtual memory protection is set up by the OS at
page granularity by setting bits in pagetable entries (PTEs).
These permission bits are checked by the hardware on memory access,
efficiently enforcing the permissions, and raising a fault when they
are violated.
For performance, \midas implements its invariant at page granularity, not object
granularity: when a syscall reads from userspace, every page touched by that
read is covered, not merely the bytes read.
Page-granularity protections are conservative compared to byte-granularity
protection and \midas maintains its invariant.
As a side-effect of its implementation, \midas does not distinguish
accesses to different parts of a page (intra-page false sharing).
False sharing leads to unnecessary page duplications, incurring performance
overhead on highly shared pages, but does not affect correctness.

For an object spanning multiple pages, \midas' design sequentially
protects each page before reading from it.
The leading pages containing the object are protected before the
later pages, allowing an attacker to potentially modify the later
pages before the syscall first reads them.
However, the attacker is prevented from modifying any of these pages
after the syscall's first read, ensuring that double fetches respect
the invariant.
If the syscall code contains a \tocttou bug, the modification will
be visible to the first fetch itself (which is used for checking for
validity of the data) and will lead to the data being rejected
straightaway.
\midas' invariant therefore prevent exploitation of double-fetch
vulnerabilities even when the fetched objects span multiple pages.
We elaborate on this case with an example in 
\autoref{sec:midas:midas:design:discussion}.

A major requirement for \midas is to allow concurrent access to pages
by user/kernel code running in parallel with a syscall which reads from
the same pages.
This requirement prevents deadlocks and improves performance \textit{vis-a-vis}
a na\"ive design which blocks all other tasks writing to pages already
read by a syscall until the syscall completes.
The na\"ive design can deadlock because it introduces dependencies between
tasks for forward progress, which we illustrate in the following example
of a system with two tasks (A and B):
\begin{itemize}
  \item Task A issues a blocking syscall which reads a user page and blocks, then
  \item Task B writes to the same user page before issuing a syscall which
  resumes task A.
\end{itemize}
In this case, if Task A's read to the page preceeds Task B's write,
Task B will be blocked waiting for A to complete its syscall.
Task A will also remain blocked waiting for Task B's syscall,
introducing a circular dependency, leading to deadlock.
The na\"ive design also introduces unnecessary delays in other cases,
such as the one described below, again with two tasks (C and D):
\begin{itemize}
  \item Task C reads from a page and sleeps for a long while,
        but does not read from the page a second time, then
  \item Task D writes to the same page after task C has read from it,
        and blocks until Task C completes and is unnecessarily delayed.
\end{itemize}
A more performant approach is to duplicate the concurrently accessed page:
the copy is kept for task C for future fetches, and task D
can write to the original and proceed without delays.

\midas must maintain multiple versions of a page read by a syscall
to maintain its invariant in the face of concurrent writes.
\midas introduces \emph{snapshots} and \emph{copies} to keep track
of page versions.
Snapshots are logical views of the page's contents at a particular time,
while the actual contents are stored in one of many copies.
Each snapshot maps to a copy, allowing the contents of the page at the
time of creating the snapshot to be read.
If multiple snapshots are taken without intervening writes to the page,
these snapshots will map to a single copy, reducing \midas' space overheads
and performance overheads for creating copies.
\midas maintains a snapshot of every page when first read by a syscall.
On a double fetch by the same syscall, the copy mapped to the snapshot
is accessed, ensuring that the data read is the same as the first time.
The latest copy of the page is used for all writes, by the syscall as
well as from concurrently running tasks, updating the page as seen
from userspace.
%
\midas' design draws parallels to multi-version concurrency control
methods for databases based on snapshot isolation~\cite{WuALXP17}.
Transactions read from a snapshot of the database state from when
they started, and writes update the up-to-date state of the database.
%
\emph{Essentially, \midas is a multi-versioning system for pages where
syscalls read from immutable versions to prevent \tocttou bugs and
syscalls and userspace both write to a single mutable version
holding the latest state of the page.}

\subsection{Page State Machine}

\begin{figure}[]
  \centering
  \includegraphics[width=\linewidth]{media/midas/midas_states.pdf}
  \caption[State diagram for a page in \midas.]
          {State diagram for a page in \midas. Reads/writes from userspace/syscall
          code are marked (u)/(s) respectively. Shading is used to represent the
          mapping from snapshots to copies.}
  \label{fig:midas:midas_states}
\end{figure}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.6\linewidth]{media/midas/doublefetch_midas.pdf}
  \caption[Diagram illustrating \midas preventing double-fetch exploitation]
          {Diagram illustrating \midas preventing exploitation of a
           double fetch of object \Code{X}.}
  \label{fig:midas:doublefetch_midas}
\end{figure}

To track multiple versions of the contents of a page when being concurrently
accessed by numerous tasks, from userspace or during a syscall,
\midas implicitly maintains a per-user page state machine.
For a page, its corresponding state machine
\begin{inparaenum}[\itshape i\upshape)]
  \item tracks snapshots for currently executing syscalls which have read it,
  \item tracks copies of the page, and
  \item maintains the mapping between snapshots and copies necessary for providing
  the correct contents to subsequent reads. % by these syscalls.
\end{inparaenum}

\autoref{fig:midas:midas_states} shows the state machine for a single page.
At every state, the page has two associated sets:
\begin{enumerate}
  \item the copies set $C = \{C_L, C_0, \dots\}$ holds multiple copies of the page over time, and
  \item the snapshots set $S = \{L, S_0, S_1, \dots\}$ tracks logical versions of the page, each corresponding to one executing syscall and each mapping to a copy.
\end{enumerate}
Reads from kernel code in a syscall use the \emph{snapshot's corresponding copy}.
Writes from user/kernel code and reads from userspace access the \emph{latest
copy} $C_L$, which is mapped in processes' address spaces.
All other copies are read-only (no matter what the original page protection is), and are used for providing snapshots to syscalls.
Read-only pages only use states 0 and 1, and writes lead to segmentation faults
(as they do on non-\midas systems).
Knowing which state the page is in allows \midas to differentiate between
faults due to \midas protecting pages and faults due to actual permissions
violations in userspace programs or the kernel.
The latest copy $C_L$ of read-only pages remains read-only in both
protected states (1 and 3).
In the following paragraphs, we describe how the state machine for a single,
writable user page transitions between its states, what triggers each transition,
and what changes are made to the copies and snapshot sets on a transition.
In \autoref{fig:midas:doublefetch_midas}, we illustrate how the state machine protects the
syscall from \autoref{fig:midas:doublefetch}.

\paragraph{State 0}
A page starts as \texttt{(unprotected, unduplicated)}.
In this state, there is a single copy $C_L$ and a single ``snapshot'' $L$.
The snapshot $L$ refers to the latest version of the page which changes
over time, and is the only mutable snapshot.
All processes where this page is mapped have unrestricted userspace read and write
access, and unrestricted kernel write access.
The remaining operation, a read from kernel code, triggers a transition to
State 1.
In \autoref{fig:midas:doublefetch_midas}, the snapshot $L$ initially contains
the value $42$.

\paragraph{State 1}
The page in State 0 transitions to the \texttt{(protected, unduplicated)} state as soon as a syscall
reads from it.
\midas first marks the page's latest copy $C_L$ read-only in all processes,
trapping writes to the page but allowing concurrent userspace reads to continue.
A new snapshot, $S_0$ linked to this syscall is allocated for this page.
For the rest of its lifetime, this syscall will only read this page from this snapshot.
Both snapshots $S_0$ and $L$ refer to the same copy $C_L$ (shown by the
blue cross-thatch in \autoref{fig:midas:midas_states}).
Prior to any writes to this page, any other syscalls which also read the page
get their own snapshots (e.g., $S_1$) all pointing to the single copy $C_L$.
The page's read-only status causes the hardware to fault on any write,
notifying \midas to transition the page to State 2.
In \autoref{fig:midas:doublefetch_midas}, the page transitions to State 1 when
the syscall first reads it, and adds a snapshot $S_0$.

\paragraph{State 2}
A page in State 1 transitions to the \texttt{(unprotected, duplicated)} state
on any write from user or kernel code.
\midas duplicates the old contents of the page from copy $C_L$, creating a
read-only copy $C_0$ (shown by green shading in \autoref{fig:midas:midas_states}).
Snapshots except $L$ (i.e. $S_0$ and $S_1$) previously mapping to $C_L$ are
mapped to the copy $C_0$.
The write then modifies the latest copy $C_L$, which is made writable again.
Note how, in this state, any read using the snapshots $S_0$ or $S_1$ reads
from the unmodified copy $C_0$ while writes directly affect $C_L$.
Certain syscalls such as \Code{rt_sigaction} both read and write from
the same user page.
A write by \Code{rt_sigaction} to the page it has previously read will update
the page's latest copy $C_L$, but not the duplicate copy $C_0$.
\midas' write policy ensures that the copy $C_L$ always holds the latest
contents of the page, up-to-date with all the writes to the page, from both user
and kernel code.
Further, \midas does not need to merge writes from userspace and syscall code
on a syscall's completion, since both directly modify the same copy $C_L$.
All other copies $C_i$ are immutable.
When the attacker writes to the page in \autoref{fig:midas:doublefetch_midas}, the
page moves to State 2, linking the snapshot $S_0$ to a copy holding the
original value $42$.
The writes from both the attacker and the syscall itself both affect
the copy $C_L$, but the read from the syscall accesses the snapshot $S_0$
and reads the same value as the first time.


\paragraph{State 3}
A separate syscall subsequently reading the page in State 2 transitions
it to the \texttt{(protected, duplicated)} state.
The new snapshot, $S_2$, points to the latest copy $C_L$.
State 3 is similar to State 1, except that there are different copies of
the page used for reading by different syscalls.
The syscall for which $S_0$ was allocated will read from the copy $C_0$,
while the syscall for which $S_2$ was allocated will read from copy $C_L$.
On a write, the page transitions to State 2 and is duplicated again,
creating another copy $C_1$: snapshot $S_2$ maps to $C_1$ while
snapshots $S_1$ and $S_0$ continue to map to $C_0$.

\paragraph{Releasing snapshots}
\midas uses snapshots to enable a syscall to read the same data from a page
during its lifetime and releases snapshots when syscalls complete.
Releasing a snapshot is possibly accompanied by a state transition
and the release of the mapped copy.
If $S_i$ mapped to the latest copy $C_L$, \midas cannot free the copy
since userspace is using it.
In this case, the page must be in State 1 or 3, and $C_L$ is read-only.
After removing $S_i$, if $L$ is the sole remaining snapshot mapped to $C_L$,
\midas makes the page writable, moving to State 0 or 2 from State
1 or 3 respectively.
If $S_i$ is mapped to any other duplicate $C_i$, \midas frees the copy along
with the snapshot if $S_i$ is the last remaining snapshot mapped to $C_i$.
If the page was in State 2, $C_L$ was writable and unmapped by any snapshot,
so \midas changes the page to State 0.
This transition is shown in \autoref{fig:midas:doublefetch_midas}, where the
snapshot $S_0$ and the copy $C_0$ are both discarded.
If the page was in State 3, $C_L$ was read-only and mapped by some other
snapshot, so \midas moves the page to State 1.
Recall that all snapshots $S_i$ except $L$ are immutable.
Any data written by the syscalls directly affect $L$.
Therefore, dropping a snapshot $S_i$ is trivial and does not require
writes from the syscall to be merged into the latest copy.

\subsection{Discussion}
\label{sec:midas:midas:design:discussion}

\paragraph{Correctness of syscalls directly updating snapshot $L$}
\midas' design lets all writes, including those from syscalls, to directly
update the latest copy of the page $C_L$ and this property maintains correctness
of system execution.
We now show that there is a valid \emph{safe} 
execution trace of a system not protected by \midas which generates the same
sequence of writes to the page, and therefore generates the same contents
of the page when the syscall ends.
%
We define a \emph{safe} trace as one that has no writes to vulnerable data between
double fetches by the kernel, and therefore does not trigger any existing
\tocttou bugs.
%
By showing that the final contents of memory after a \midas syscall has a
corresponding execution without \midas (which we assume to be correct)
leading to the same contents,
we can conclude that the execution of the \midas syscall is also correct.
For this proof, we assume that no syscall reads the same object after writing
to it (r-w-r pattern).
Such syscalls do not exist in the Linux kernel, and are discussed below.
Therefore, our syscalls write to an object after completing all of their reads
of that object.

Consider a page holding a single-byte object $O_0$, and the
sequence of operations to this byte during a \midas syscall be
$Ops = \{Op_0, Op_1, \dots \}$.
Each operation is a tuple $(r/w, k/u)$ specifying whether the
operation was a read or a write, and whether the operation was due to
a user or kernel instruction.
Suppose there was no attempt to exploit a \tocttou bug, i.e., between
any two read operations by the same syscall, there was no write to
this object.
% \mat{Second part of the conflict.}
% In case of the above mentioned scenario (1), which covers no concurrent
% writes, there are no writes to this object between any two read operations by
% the same syscall.
In this case, \midas reads the same value from its snapshot of the
object as is present on the latest version.
The same sequence of operations on a non-\midas system would be valid and
safe, since the object value does not change between the kernel's double
fetch and the syscall reads the same value on this system.

% \mat{Third part of the conflict.}
% Let us know focus on scenario (2) -- concurrent writes during a syscall's
% execution -- and
%
Assume there was an attempt to exploit a \tocttou bug:
a write $Op_1$ exists between two syscall reads $Op_0$ and $Op_2$.
\midas protects the syscall ensuring that $Op_2$ does not see the
effect of $Op_1$ by reading from a snapshot instead of the latest
copy $C_L$.
Since our syscalls are assumed to not contain any r-w-r pattern,
any writes by the syscall happen after $Op_2$.
Let us assume that the syscall's write is $Op_3$.
We can generate a valid, safe execution on a non-\midas system
by moving the attacker's write to after the last read by the
syscall, i.e., $Ops = \{Op_0, Op_2, Op_1, Op_3\}$.
The syscall in this system reads the same value both times, and
hence has the same execution as that in the \midas case.
The value of the object when the syscall completes is that
written by $Op_3$ in both cases (or that written by $Op_1$ when
the syscall does not have a final write).
Since the syscall has the same execution and the final value of
the object is the same, the execution of the \midas system
is the same as that of the non-\midas system.
In general, any trace of operations on a \midas system can
be translated  to a valid, safe trace on a non-\midas system
by moving malicious writes to an object to just after the last
double fetch of that object.
Multiple syscalls in \midas can therefore write to the same object
without affecting
correctness, because an equivalent, valid, safe non-\midas trace
exists where all of the writes have been postponed, in the same order
to after the double fetch reads.

\begin{table}
  \begin{center}
    \begin{tabular}{  !l  ?l }
    \toprule
      \rowstyle{\bfseries}
      System Call   & Exemption reason \\
    \midrule
      \Code{futex}  & Relies on concurrent write \\
      \Code{execve} & Remaps address space \\
      \Code{write}  & Invulnerable, improves performance \\
    \bottomrule
    \end{tabular}
  \end{center}
  
  \caption{System calls uninstrumented by \midas.}
  \label{tab:midas:except_syscall}
  \end{table}

\paragraph{Exemptions}
Syscalls such as \Code{futex} rely on user data changing between double
fetches to implement their functionality and cannot be protected by
\midas.
These syscalls are listed in \autoref{tab:midas:except_syscall}.
The \Code{futex} syscall implements a fast synchronization mechanism
for userspace and relies on atomic writes from concurrent userspace
threads to update a condition the syscall is waiting for.
Subjecting a \Code{futex} syscall to \midas' invariant will prevent
it from ever waking up the waiting task.
Such syscalls cannot be protected by \midas, and we implement an
exemption list to prevent transitions in the state machines of pages read
by these syscalls.
The code for exempted syscalls must be manually inspected for double-fetch
vulnerabilities.
Crucially, exempting these syscalls from \midas' protection does not
affect the security of other syscalls containing double fetches.
Any writes from these syscalls are subject to the same rules described
in the state machine, and cannot break \midas' invariant.
\midas can also implement finer-grained exemptions based on syscall
parameters. Those were not necessary for Linux.
% Mat: the below is a bit stating the obvious, therefore commented.
%
% Other kernels may contain any number of
% syscalls which require exemption from \midas' protection, and
% they all need to be properly added to the exemption list.
% Finer grained exemptions based on syscall parameters can also be
% implemented, but was found unnecessary for Linux.
% A kernel where a majority of syscalls require exemption might not
% benefit from \midas' protection.


\paragraph{Syscalls with read-write-read patterns}
A (hypothetical) syscall that reads from an object, writes to it, and
then reads back the updated object cannot be protected using \midas.
\midas' invariant will ensure that the second read is identical to the first,
and does not reflect the intermediate write.
Such syscalls must remain exempt from \midas' instrumentation.
During extensive tests, we did not find any other syscall which exhibits this behavior in the Linux
kernel.

\paragraph{Syscalls with false sharing}
Another hypothetical type of syscall could struggle with \midas'
instrumentation due to false sharing.
Suppose a page contains two objects, $O_0$ and $O_1$, and a syscall
sequentially reads $O_0$ then $O_1$.
Due to \midas' invariant being enforced at page granularity and
false sharing of the page between these objects, \midas guarantees that
the value of object $O_1$ read is the same as what was contained when it
first read object $O_0$.
A syscall requiring the value of $O_1$ to change between these two
points in time would not work with \midas' protections.
Such a hypothetical syscall, requiring concurrent modifications to its
arguments, could exist to support some synchronization mechanism
similar to a \Code{futex} and can be safely exempt from \midas' invariant.
%
During extensive tests, we did not find any other syscall which exhibits this behavior in the
Linux kernel.


\begin{figure}[]
  \centering
  \includegraphics[width=0.7\linewidth]{media/midas/doublefetch_midas_twopages.pdf}
  \caption[Diagram illustrating \midas preventing multi-page double-fetch exploitation]
          {Diagram illustrating \midas preventing exploitation
          of a double fetch of an object \Code{X} spanning two pages.}
  \label{fig:midas:copy_two_pages}
\end{figure}

\paragraph{Example: Objects spanning multiple pages}
\autoref{fig:midas:copy_two_pages} shows \midas protecting a syscall which
has a double fetch for an object spanning multiple pages.
Here, the two pages containing the object \Code{X} are accessed as
\Code{X[0]} and \Code{X[1]}.
The attacker tries to attack the syscall by changing the value of the
second page:
\begin{inparaenum}[\itshape i\upshape)]
\item between the syscall's first reads of \Code{X[0]} and \Code{X[1]}, and
\item between the first and second fetches of X.
\end{inparaenum}
\midas ensures both fetches return \Code{X=(42,0)}.
Critically, any existing \tocttou bugs are not triggered since both fetches
read the same, possibly invalid, value of the object.
Note how the situation is identical to one where the malicious write
to \Code{X[1]} happens before the syscall starts.

\paragraph{Preventing deadlocks by design}
\midas' design is free of deadlocks, and exempts syscalls which
require violation of its invariant from triggering particular
state-machine transitions.
Userspace reads always succeed, using the latest copy $C_L$ of the
accessed page.
Writes from userspace and kernel code succeed directly if the
page is in State 0 or 2, and trigger a fault otherwise.
Handling these faults involves creating a new copy of the page and
setting the page writable.
Reading from kernel code involves creating a new snapshot and
setting the page read-only.
None of the aforementioned operations relies on other operations
on the same page to complete and all are finite time.
None of the operations on a page rely on operations on other pages.
A single, per-page lock can serialize operations on that page
and assure forward progress.

\paragraph{Detecting double fetches}
\midas' state machine for pages enables the precise detection of double fetch
bugs, turning it into an effective sanitizer and developer debugging tool in
addition to being an efficient mitigation.
When a syscall first reads from a user page, it creates a snapshot
of that page.
On future reads, the snapshot is used in order to maintain the
invariant.
While reading from a page, implementations must check
if a snapshot exists for the syscall: if yes, the snapshot is used
for the read, otherwise a new snapshot is created and then used
for the read.
The existence of a snapshot means the syscall had previously
read from this page and had then created this snapshot, implying a double
fetch.
Unfortunately, this approach is prone to false positives due to false sharing.
The two reads might read from the same page, but access entirely
disjoint bytes.
\midas currently reports double fetches at page granularity.
A precise sanitizer could maintain a bitmask of accessed bytes to
prune false positives.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\midas Implementation}
\label{sec:midas:midas:impl}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Our \midas prototype implements the state machine described in
\autoref{sec:midas:midas:design} on Linux version 5.11, targeting the x86-64
architecture.
A page protected by \midas transitions between states on
either a kernel read to user memory, or when user or kernel code
writes to protected, read-only memory (see \autoref{fig:midas:midas_states}).
\midas can be implemented on any operating system kernel that
\begin{inparaenum}[\itshape i\upshape)]
\item systematically uses transfer functions for reading from userspace, and
\item on any architecture which implements hardware-controlled access
control to memory through page tables.
\end{inparaenum}
The first requirement enables \midas to implement transitions on
kernel reads from user memory.
The Linux kernel uses the \Code{raw_copy_from_user} interface which
we instrument for our prototype.
The second requirement causes the hardware to raise a fault on
writes to \midas-protected pages,
directing execution on the processor to a pre-defined exception
handler in the OS.
Our prototype instruments Linux' fault handler in the function
\Code{handle_pte_fault} to implement the write-triggered transmissions
from states 2 and 4.
Overall, our prototype adds around $1,100$ lines of code and modifies
17.
Our design allows the changes to be mostly limited to the memory
subsystem, and in general does not require individual syscalls to
be modified.
Only one syscall~(\Code{clone}) required code modification.

\subsection{Tracking Page State}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[]
  \centering
  \includegraphics[width=0.75\linewidth]{media/midas/book-keeping.pdf}
  \caption[\midas{}' bookkeeping information for a page.]
          {Bookkeeping information for a page.}
  \label{fig:midas:midas_bookeeping}
\end{figure}

\midas needs to track the state for every userspace page, including
its snapshot and copy sets.
\autoref{fig:midas:midas_bookeeping} shows the data structures used to
track a page's state in our prototype.
Linux maintains a \Code{struct page} object for every frame of
physical memory.
We augment \Code{struct page}  with a list holding the snapshots
for this page, excluding the latest snapshot $L$.
Each snapshot has a pointer to its copy.
In the figure, the snapshots $S_1$ and $S_0$ share the copy $C_0$.
We are aware of the strong aversion of the
Linux kernel developer community towards increasing the size of
\Code{struct page}.
An alternate implementation can use a hashmap to
map from a page's frame number to its snapshots list or
reuse existing data members (e.g., \Code{struct list_head lru} which
can be used as a generic list by page owners).

Each pagetable entry for a user page in different address spaces
maps the copy $C_L$, enabling userspace to directly access the page
with reads (and writes for writable pages).
We use one software-controlled bit (SW3) in the pagetable entries
to track the protection status of the page, and another
(SW2)\footnote{The SW2 bit is alternatively used by the experimental Software Dirty Pages feature of
Linux, and cannot be run alongside \midas in our prototype.}
to track the original protections for the page.
SW3 is set whenever the page is in one of the two protected
states (1 and 3).
On a write-triggered protection fault, SW3 can be read to
efficiently determine if the fault was due to \midas' protection
mechanisms, triggering a state change, or due to buggy software
accessing a page with illegal permissions, triggering a signal to
the task.
Other architectures might have fewer software-usable
bits in the page table, and implementations of \midas would
require storing the protection status of pages in a separate data structure.
The duplication status of the page is implicitly encoded in the
snapshots: the page is duplicated when any of its snapshots
holds a pointer to a copy other than $C_L$.

Changing a page's protection state requires PTE updates
in all address spaces where the page is mapped.
The page's \Code{struct page} structure includes a reverse-map
listing for all of these pages, and the corresponding virtual
address in each.
Our prototype uses this mapping to change PTE permissions across
all address spaces for a page.


\subsection{Kernel Reads from User Memory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[]
  \centering
  \includegraphics[width=0.6\linewidth]{media/midas/copy_from_user.pdf}
  \caption[\midas: Flowchart for the transfer function \Code{raw_copy_from_user}]
          {Flowchart for a syscall using the transfer function
          \Code{raw_copy_from_user}
          for reading from userspace.}
  \label{fig:midas:copy_from_user}
\end{figure}

Syscalls reading from user memory the first time triggers the
allocation of a new snapshot.
If the page is not protected (states 1 and 3), the read also
triggers a state change where the kernel protects the page
in all address space that it is mapped in.
\autoref{fig:midas:copy_from_user} shows the flowchart of the steps
implemented by the kernel function \Code{raw_copy_from_user} for
reading from user memory.
This function also uses the kernel's \Code{mark_page_accessed}
interface to move the page to the ``Active'' state for the
kernel's swapping mechanism, making the page ineligible for being
swapped out.
We also implement \Code{get_user} and \Code{unsafe_get_user}
(used by the kernel for small reads) as a call to \Code{raw_copy_from_user}.

\paragraph{Exemptions}
Our prototype \midas kernel exempts a couple of functions
from \midas' invariant (in addition to those described in
\autoref{sec:midas:midas:design:discussion}), and these functions are
therefore not instrumented
to follow the aforementioned steps while accessing userspace
memory.
First, \Code{raw_copy_from_user_inatomic} is a special
transfer function used by the kernel to
read user memory in special situations such as a kernel
oops\footnote{A kernel oops is triggered when the kernel detects a
problem while running which can affect its proper functioning, such
as corrupted data structures.
A more severe version, a kernel panic, causes the kernel to stop
executing, expecting data loss or damage if it does.}
where the kernel reads user memory to provide a backtrace.
In this severe situation, the kernel's goal is to collect debug
information before its imminent termination and no \tocttou protection
is needed.
Second, we also exempt the \Code{write} system
call's reads from user memory from instrumentation.
The \Code{write} syscall takes three arguments: a
file descriptor passed as a register, a pointer to a user
buffer and a count of bytes to be written to the file.
While the write to the file's pages is sensitive, and
\midas takes care to ensure that it follows the page state
machine, the read from the userspace buffer is not.
The syscall reads from userspace only once, and its data
is only used for copying into the file.
An attacker who modifies the user buffer concurrently with
the syscall only manages to change the contents written to
file, which it could have done anyway since it has access to
this buffer.
A kernel developer can similarly exempt other syscall which
they can prove to be secure from double-fetch bugs.


\subsection{Handling Faults}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[]
  \centering
  \includegraphics[scale=0.85]{media/midas/pagefault.pdf}
  \caption[\midas{}: Flowchart for handling a page fault.]
          {Flowchart for handling a page fault. Shaded
          operations are unmodified.}
  \label{fig:midas:fault_handling}
\end{figure}

\begin{figure}[]
  \centering
  \includegraphics[scale=0.85]{media/midas/pagefault_cow.pdf}
  \caption[\midas: Flowchart for handling a page fault to a COW page.]
          {Flowchart for handling a page fault to a COW page.}
  \label{fig:midas:fault_handling_cow}
\end{figure}

The memory management unit generates a fault when kernel or user code accesses
a page without having the correct permission in the corresponding PTE.
\midas marks writable pages read-only to protect them in
states 1 and 3, allowing the kernel to detect writes to these pages.
A common OS mechanism, copy-on-write (COW) pages, also uses
permissions in the PTE to detect when COW pages need to be copied.
The PTE's present bit are used to store pointers to file-backed pages
when they are swapped to disk.
\autoref{fig:midas:fault_handling} shows the flowchart implemented by
\Code{handle_pte_fault} to handle faults for userspace addresses.

The page-fault handler first checks if the PTE is NULL, and if so
knows that it must allocate a page.
If the required page is anonymous, the page can be allocated as usual.
Otherwise, for file-backed pages, the handler has to check if the
page is already in a protected state (states 1 and 3) by reading
the SW3 bit of the PTE and if so, transitions to the required state
and allocates a new copy.
Pages in states 0 and 2 can be directly mapped, and subsequently
accessed.

For non-NULL PTEs, the handler checks if the PTE indicates that the
page is present.
Non-present pages need to be swapped in.
After finding the page, \midas then checks if the page was previously
swapped in by any other task and is now in a protected state.
For protected pages, \midas implements the required state change based
on whether the faulting access was a read or a write.

In the remaining case, faults for a present page indicate a
permission fault (for example, a write to a read-only page).
If the page is not a COW page, the handler then checks if the page
is in a protected state by checking the SW3 bit.
If the page was protected, a new copy is allocated and the page
transitions to the following state.
For non-protected pages, however, the fault implies a real access
violation, sending a signal to the process.

COW pages represent separate virtual pages from different
address spaces mapped to the same physical page.
An example of a COW page protected by \midas is shown in
\autoref{fig:midas:fault_handling_cow}, where logically-separate pages A and B
are actually mapped to the COW page.
COW pages cannot be in states 2 or 3, since they cannot have multiple
\midas copies.
COW pages in state 0 can be dealt with by the kernel's standard
duplication method (not \midas' duplication).
For a COW page in state 1, its list of snapshots can correspond to
reads from syscalls for threads in different address spaces.
In \autoref{fig:midas:fault_handling_cow}, we show snapshots $S_A$ and
$S_B$ corresponding to syscalls for threads in different address
spaces (containing A and B respectively).
These snapshots correspond to different logical pages, but are
all squashed into the snapshots list of the single COW page.
Therefore, after the kernel duplicates the COW page (new page
B created, in \autoref{fig:midas:fault_handling_cow}), \midas moves
the snapshots for the faulting process ($S_B$) to the new page.
Here, \midas also updates the protected page list in the
affected syscalls' \Code{task_struct}s so that these structures
correctly refer to the new page.
Finally, the new page is transitioned to its next state to allow
for the write to occur, creating a new copy ($C_0$) for the
snapshot $S_B$ to read from.

We ensure that \midas' modifications to the fault handler
correctly handle concurrent faults and do not cause additional
nested faults.
During concurrent faults for the same page, only one thread
changes the page's state whereas the other directly uses the new
state.
The kernel's split page-table lock is reused to serialize state
changes.
We also ensure that the only additional accesses to user memory
within the handler (used for duplication) happen when the page
is assured to be in memory and correctly mapped.
All nested faults are therefore caused by existing kernel code
and do not interact with \midas' modifications.

\subsection{Syscall Completion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

On syscall completion, \midas cleans up snapshots allocated for
the syscall by instrumenting the end of \Code{do_syscall_64}.
\midas goes through the list of all the pages for which the
executing syscall has a snapshot, and frees those snapshots.
For snapshots which were the last to point to a copy, that
copy is also freed.


\subsection{File System Writes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\midas instruments file-system writes to protect the kernel
from modifications via kernel mappings.
When a \Code{write} syscall writes to a file, it actually
writes to copies of pages of the file stored in memory within
a page cache.
In the spirit of abstraction, the kernel does not directly write to
these pages, but calls the relevant file-system (FS) driver instead.
The FS driver will access the page using kernel mappings when writing to pages in the page cache.
Since \midas only protects userspace mappings for protected pages,
writes by FS drivers will not raise a fault.
To comprehensively protect the page, any implementation needs to
instrument FS drivers' write functions.
Fortunately, FS drivers provided with the kernel follow a simple
recipe: for pages not in the page cache, the driver executes
FS-specific code to read the page into the page cache and then
call a generic function (\Code{generic_file_write_iter}) to actually
write the data into the page.
Instrumenting this generic function, therefore, protects the kernel
for a wide range of common file-systems (including ext4, nfs and
ntfs). \footnote{A more comprehensive list of kernel-provided FS drivers
protected via \Code{generic_file_write_iter} includes v9fs, ADFS, AFFS,
AFS, BFS, CIFS, eCryptfs, extFAT, ext2, F2FS,  FAT, FUSE, HFS, HFS+,
hostfs, HPFS, JFS, JFFS2, Minix, NILFS2, OMFS, OrangeFS, ramfs, ReiserFS,
SystemV, UBIFS, UDF, UFS, VboxSF, shmem.}
The added instrumentation checks whether the target page is
protected, and if so, transitions it to the next state and
creates a copy of the page before writing to the latest copy.

Our current prototype does not, however, protect out-of-tree drivers
which are not distributed with the kernel if they do not use the
\Code{generic_file_write_iter} function.
A user with superuser privileges can load a insecure module implementing a
FS driver which does not implement \midas checks.
A malicious superuser is, however, outside our threat model.
% Mat: IMO a very weak argument and always the case, so rather than waste
% precious time here, I've commented out the below as it distracts from our key
% argument IMO.
%
% A more reasonable threat involves a sysadmin unwittingly loading a
% insecure driver which a non-privileged user can then use to
% exploit a \tocttou bug.
% One solution would be for the kernel to inspect the relocations table of
% a new module while loading it to see if it uses \Code{generic_file_write_iter}
% and raising a warning if it does not.


\subsection{New Mappings to Protected Pages}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Our \midas prototype preserves the state machine for user pages
across operations which create new mappings to a page to prevent
attacks which rely on mappings being created between double fetches.
The \Code{mmap} syscall is responsible for creating new virtual
memory mappings for processes, and requires instrumentation.
When \Code{mmap} is called with the \Code{MAP_POPULATE} flag, or
on the first access to the page, the \Code{mm_populate} function
is responsible for actually mapping the correct page in the
page table.
In our prototype, we check if the page being mapped is protected,
and if so, correctly protect the new mapping too.
Another syscall, \Code{clone}, duplicates a process' address space
when called without the \Code{CLONE_VM} flag, creating new mappings
to pages.
We instrument \Code{clone} to ensure that new mappings for protected
pages are also correctly protected.


\subsection{Discussion}
%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Optimizations on capable hardware}
To protect a page in an address space, a \midas implementation
needs to change the permissions in the page table for that page.
Modern CPUs cache virtual memory translations in per-core
Translation Lookaside Buffers (TLBs) which need to be (partially)
flushed on page-table updates (TLB shootdown).
On most CPUs, the core updating permissions will perform a global
shootdown to ensure that other TLBs for cores executing in the
same address space are also updated.
Implemented with inter-processor interrupts, global shootdowns
are expensive.
In our evaluation, 21\% of the runtime of the load generator
\Code{bombardier} used for stressing the Nginx server was spent
performing TLB shootdowns when running on the \midas kernel.

A more efficient solution would be to have special hardware support
for invalidating TLB entries globally, not just on the executing
core.
The AMD64 architecture manual~\cite{amd64prog} lists such an instruction
(\Code{INVLPGB}), though it is only implemented on a limited selection
of server processors only (e.g., 3rd Generation AMD EPYC).
The ARM v8-A architecture manual~\cite{armv8a} lists similar instructions
\Code{TLBI ASIDE1}\texttt{\textbf{IS}} and \Code{TLBI ASIDE1}\texttt{\textbf{OS}} which invalidate all PTEs
of a page within a cluster of cores but not for cores in other clusters
(Inner Shareable Domain) and cores across clusters (Outer
Shareable Domain) respectively.
Academic proposals for hardware TLB 
coherence~\cite{VillaviejaKVERMNCU11, YanVCB17, RomanescuLSB10} would also
benefit \midas by reducing the overheads for PTE modification.

Alternate architectures~\cite{0003BOBFP21midgard,ChaseLFL94SASOS} with a single,
system-wide translation table
would also benefit \midas by having a single page table to
update instead of multiple page tables for each address space a page
is mapped in.

\paragraph{Porting to other OSs}
\midas can provide \tocttou protection on other operating systems by
tracking the states of each page and implementing state transitions
as required.
OSs track page state in per-page state structures,
such as \Code{vm_state_t} for BSD-based OSs (*BSD) such as FreeBSD and XNU.
An implementation on these OSs must instrument the
read transfer function(\Code{copyin} for *BSD) to transition to states 1 and 3.
The OS' fault handler (\Code{vm_fault} on *BSD) will trap on writes to
protected pages, and needs to be modified to implement the required page
duplication and state change.

The remaining OS modifications for \midas support depends on
the OS' features.
If an OS allows userspace to map file pages, filesystem code to write
to these page needs to be modified.
Other syscalls which create/modify mappings to userspace pages will
also have to be instrumented to ensure that the new mapping respects the
page's state.
Such modifications are OS-specific, making it difficult to recommend
a generic methodology.


%%%%%%%%%%%%%%%%%%%%
\section{Evaluation}
%%%%%%%%%%%%%%%%%%%%

In this section, we emperically verify \midas' ability to mitigate
a known double fetch vulnerability, and quantify \midas' overhead on
workloads with different characteristics including both compute-bound
applications which rarely use syscalls and a mix of syscall-heavy applications
which heavily rely on the kernel's performance.

\subsection{Mitigation of CVE-2016-6516}
%%%%%%%%%%%%%%%%%%%%

\definecolor{mygreen}{RGB}{62, 123, 49}
% \begin{minipage}{\linewidth}
\begin{lstlisting}[language=C, escapeinside={<@}{@>},
                  basicstyle=\ttfamily, frame=single, numbers=left,
                  captionpos=b,
                  label=lst:midas:cve-2016-6516,
                  caption={CVE-2016-6516: Vulnerable double fetch in \Code{ioctl_file_dedupe_range}.
                          Lines in green show the fix and testing code.},
                  float]
  //First fetch
  if(get_user(count,&argp->dest_count))
  {...}
  //Using first fetch
  size = offsetof(..., info[count]);
  //Secong fetch
  same = memdup_user(argp, size);
<@\texttt{\color{mygreen}{+ \textit{//Added check for bug}}}@>
<@\texttt{\color{mygreen}{+ \textbf{if}(same->dest\_count != count)}}@>
<@\texttt{\color{mygreen}{+ \ \ printk("Bug triggered");}}@>
<@\texttt{\color{mygreen}{+ \textit{// Fix: copy over original count}}}@>
<@\texttt{\color{mygreen}{+ same->dest\_count = count;}}@>
  //Using second fetch
  ret = vfs_dedupe_file_range(file,same);
\end{lstlisting}
% \end{minipage}

CVE-2016-6516 is a known vulnerability in kernels prior to version
4.7 in a file-system \Code{ioctl}.
The vulnerable code is shown in \autoref{lst:midas:cve-2016-6516} and is
triggered when the value of the \Code{dest_count} object differs between
the two fetches (in lines 2 and 7).
\Code{memdup_user} uses the value from the first fetch for allocating a buffer
and copying in an array of descriptors from the user in line 7.
\Code{memdup_user} also contains the second fetch of \Code{dest_count}
which is later used in the function \Code{vfs_dedupe_file_range}.
An attacker who increases the size of \Code{dest_count} between the
two fetches will cause the kernel to access the copied array out-of-bounds,
causing a heap buffer overflow.

For verifying \midas' defense, we introduce a non-faulting assertion
check into the function~(lines 9--10) and run a known
exploit.\footnote{\url{https://github.com/wpengfei/CVE-2016-6516-exploit/tree/master/Scott\%20Bauer}}
The condition checks whether the fetched value of the user object (\Code{dest_count})
had changed, indicating a successful attack, and prints a message.
Finally, we re-introduce the fix for the bug (line 12), fixing the value of
\Code{dest_count} in \Code{same} to that from the first fetch.
In this setup, we can detect when the conditions for triggering the bug are met,
but also revert to a correct state allowing the kernel to safely
continue.
The exploit was able to successfully trigger the bug on the baseline kernel
every time over 10 runs.
With \midas enabled, the exploit was never triggered, i.e., both fetches
returned the same value on every call.\\


\subsection{Performance evaluation}
\label{sec:midas:perf}
%%%%%%%%%%%%%%%%%%%%

We evaluate \midas on
\begin{inparaenum}[\itshape i\upshape)]
\item microbenchmarks targeting specific common syscalls,
\item workloads from two benchmark suites: the NAS Parallel
    Benchmark (NPB)~\cite{npb} and select workloads
    from the Phoronix Test Suite (PTS)~\cite{pts}, and
\item the webserver Nginx.
\end{inparaenum}
NPB includes compute-intensive multiprocessing workloads with a
low, but non-negligible syscall rate.
NPB therefore demonstrates the ability of \midas to
scale to systems where pages are protected across numerous
address spaces.
PTS includes a variety of benchmarks, both compute bound and
I/O bound representative of both desktop and server workloads.
PTS includes syscall-heavy applications with varying degrees
of parallelism.
The Nginx webserver is capable of both high request service rates
and scalability with multiple worker processes.
We do not include the SPEC CPU2017 benchmarks
as they are heavily compute bound and designed to isolate userspace
performance without syscalls, and are impervious to kernel performance.
SPEC benchmarks would unfairly bias performance in favor of
\midas.

The testbench for the evaluation consists of a desktop machine
with an 8-core Intel i7-9700 processor and 16GB DRAM running
Ubuntu 20.04 LTS. This configuration and CPU is commonly used on desktop
machines and workstations.
%
To eliminate the effect of dynamic frequency and voltage
scaling (DVFS), we set the processor to run at constant
frequency of 3.0GHz which is this model's base frequency.
In the \emph{baseline} configuration, we run the testbench
with the mainline kernel v5.11 available from Ubuntu's package
repository.
The \emph{\midas} configuration runs our prototype \midas kernel
also based on kernel v5.11.
For particular benchmarks, we also run the \emph{\midas{+}write}
configuration which also runs our prototype \midas kernel
but instruments all syscalls including \Code{write}.

\begin{figure}[!t]
  \centering
  \includegraphics[width=\linewidth]{media/midas/midas_performance.pdf}
  \caption[\midas performance comparison]
          {\midas' performance on microbenchmarks, NPB and PTS benchmarks
          relative to the baseline kernel.}
  \label{fig:midas:midas_performance}
\end{figure}

\begin{table}
  \centering
  \begin{tabular}{!l ?l}
    \toprule
    \rowstyle{\bfseries}
    Microbenchmark          & Top syscalls used \\
    \midrule
    File creation           & \Code{openat}, \Code{fstat}, \Code{write}, \Code{close} \\
    Thread/Process creation & \Code{mmap}, \Code{clone}, \Code{exit}, \Code{wait} \\
    Program launch          & \Code{mmap}, \Code{execve}\Code{readlink}, \Code{openat} \\
    Memory allocation       & \Code{brk} \\
    \bottomrule
  \end{tabular}
  \caption{Prominent syscalls used by OSBench microbenchmarks.}
  \label{tab:midas:osbench_syscalls}
\end{table}

\paragraph{Microbenchmarks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We test \midas on microbenchmarks from
OSBench~\cite{osbench}.
The programs use \Code{libc} interfaces such as \Code{fopen},
\Code{pthread_create}, \Code{fork} and \Code{malloc} for creating files,
threads, processes and for memory allocation respectively.
\autoref{tab:midas:osbench_syscalls} lists the prominent syscall usage
for these workloads.
\autoref{fig:midas:midas_performance} shows \midas' performance
(time per operation)
on OSBench relative to the baseline kernel, with overheads ranging from
zero to 5.3\%.

\paragraph{NAS Parallel Benchmarks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
NAS Parallel Benchmarks (NPB)~\cite{npb} is a benchmark introduced by
NASA.
NPB consists of several parallel programs using different communication
patterns and is available for two frameworks for parallel programming:
OpenMP and MPI.
OpenMP~\cite{dagum1998openmp} is a compiler extension that splits a
program's execution to multiple threads.
All threads still use the same address space, keeping the overhead minimal.
MPI~\cite{snir1998mpi} implements parallel execution by launching multiple
processes which communicate by message passing.
The two technology stacks have different frequency of syscalls due to
different communication methods.
Communication through kernel syscalls for either stack will incur overhead
due to \midas' protection.
Additional global TLB shootdowns (for snapshot synchronization) added by
\midas will also affect the performance of such parallel benchmarks.

We run NPB benchmarks of class A on our testbench, executing
4 threads or processes in parallel.
The benchmarks' runtime varies between 10 seconds and 8 minutes,
and are all long enough for the kernel to reach equilibrium.
Certain benchmarks require a parallelism number which is a perfect square.
On our 8-core CPU, having 4 compute-bound threads/processes instead of 16 allows
all threads to run without time sharing.
\autoref{fig:midas:midas_performance} shows \midas' performance for both MPI and OpenMP,
normalized to the performance of the baseline system with the same parallelization
framework.
On average, \midas achieved $96.3\%$ of the baseline system's performance on
both frameworks.
\midas' performance for the \Code{ep} (Embarrassingly Parallel) benchmark is
closest to that of the baseline, since it has low communication overheads.
\midas shows low overhead ($3.7\%$) for compute-intensive, parallel workloads.


\paragraph{Phoronix Test Suite}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The Phoronix Test Suite (PTS)~\cite{pts} includes a large set ($>500$) of
open-source benchmarks, of which we have chosen a range of benchmarks
suitable for evaluating both desktop and server performance.
We bias the selection to benchmarks that require (heavy) kernel activity to
test the overhead of \midas' instrumentation.
A sole benchmark, OpenSSL, is included to represent single-threaded,
compute-bound workloads for which kernel performance is less relevant.
The benchmarks are also varied, ranging from single-threaded (Pybench) to
multi-threaded, multi-process workloads (Apache).
At the extreme, we have an inter-process communication (IPC) benchmark 
transferring tiny, 128-byte
buffers between processes which spends all of its time in syscalls
and whose performance is entirely dependent on kernel IPC performance.

We plot \midas' performance relative to the baseline kernel on
these benchmarks in \autoref{fig:midas:midas_performance}, roughly ordering
workloads in increasing order of syscall dependence from left to right.
For benchmarks for which PTS reports runtime, we compute the inverse
of the runtime as performance.
Benchmarks with low syscall frequency such as OpenSSL,
Pybench and Git have correspondingly low dependence on kernel performance.
Accordingly, these benchmarks see a negligible overhead when running
on our prototype kernel.
The benchmark titled ``Linux'' represents compilation of the Linux kernel.
While compilation is mostly compute bound, compiling the Linux kernel requires
accessing a large number of source files, resulting in the creation
of a large number of compiler processes each of which read and create
files.
\midas experiences a small, but non-negligible overhead of $3.5\%$ on this workload.
Redis requires syscalls for receiving and replying to requests, but
processes its transaction entirely in-memory.
Our evaluation prototype achieves practically identical results as the baseline,
highlighting the final prototype's competitive performance.
The webservers, Apache and Nginx require network and file-system I/O,
and rely heavily on syscall performance.
We see that Nginx, which is a higher-performance webserver, sees a larger
overhead.
IPC, which implements 128 byte transfers between
two processes over a TCP connection, is almost entirely bound by kernel
performance and sees a performance overhead of $3.4\%$ on \midas.

Our prototype \midas kernel benefits significantly from
exempting particular, proven-safe syscalls from instrumentation.
While we exclude \Code{write}-like syscalls from \midas because they
are not vulnerable to double-fetch bugs, we also evaluated the
performance cost of an unoptimized implementation (\midas{+}write)
which also instruments these syscalls.
To highlight the worst-case performance of the unoptimized implementation,
we evaluate the performance of the IPC benchmark on \midas{+}write due
to its high frequency of \Code{write} syscalls.
With \midas{+}write, the performance of the IPC benchmark falls to
$12.6\%$ of the baseline, a further degradation of $84\%$ compared
to \midas, showing that developer effort towards properly exempting
frequently called \emph{safe} syscalls from \midas protections is crucial
towards for implementations to maintain competitive performance
compared to the baseline.

\paragraph{Memory overhead}
Our prototype incurs memory overhead due to metadata, tracking page snapshots
and copies.
At any instant, the memory overhead mainly depends on the number of executing
syscalls (limited by the core count) and the number of page copies for these
syscalls.
On average, for every 1000 syscalls issued by the PTS benchmarks, our prototype
created 236 snapshots (32B each) and 54 copies (4KB each).
We can see that the occurrence of copies is low, resulting in negligible
memory overhead.

\subsection{Overhead breakdown}
%%%%%%%%%%%%%%%%%%%%

\begin{figure}
  \centering
  \includegraphics[width=0.7\linewidth]{media/midas/overhead.pdf}
  \caption{Classification of overheads for various benchmarks due to \midas.}
  \label{fig:midas:overhead_class}
\end{figure}

In this section, we explore the sources of \midas' overhead by analyzing
\Code{perf} traces for three workloads: thread creation from OSBench, linux
compilation from PTS, and Nginx.
We aim to classify overheads into the various kernel function we instrumented:
\begin{inparaenum}[\itshape i\upshape)]
\item user copy in transfer function,
\item page duplication on page fault,
\item metadata cleanup on syscall end, and
\item filesystem operations.
\end{inparaenum}

To estimate the time spent in each function, we create FlameGraphs for
each workload\cite{GreggFlameGraph} using samples of processor state, including
the call stack, collected over 30 second periods by \Code{perf record}.
After identifying one binary for the workload from the FlameGraph, we estimate
the overhead for a function as the difference in execution time attributed to
that function between the baseline and \midas systems.
The total overhead is estimated from the throughput figures obtained from
\autoref{sec:midas:perf}.

\autoref{fig:midas:overhead_class} shows the breakdown of overheads for three
workloads.
As expected, metadata tracking and duplication causes most overheads
for the user copy and fault handling functions respectively.
The results for the Linux build breakdown differs 
from the other workloads
in the large portion of
the unaccounted overhead (labelled ``Other'').
This anomaly stems for the fact that Linux's compilation runs a large number (1000s)
of processes, of which the compiler accounts for less than~50\% of the
total execution time.
The reported breakdown accounts for overheads on the compiler, but not
all the other processes.

Both page faults and user copies cause state changes for a page, and thereby
change the page's access permissions in the PTE.
The resulting TLB flush accounts for 0.3\%, 0\% and 1.1\% overhead for
thread creation, compilation, and Nginx respectively.
The load generator \Code{bombardier} used for loading Nginx, however, sees
a much larger overhead for TLB flushing, accounting for
21\% of its execution time.

\subsection{Case study: Nginx}
%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.75\linewidth]{media/midas/nginx_performance.pdf}
  \caption[\midas: Request rates and throughput for the Nginx server]
          {Request rates and throughput served by the Nginx server for
          static pages.}
  \label{fig:midas:nginx_perf}
\end{figure}

To better understand \midas' behavior under varying syscall
rates and different core configurations, we study Nginx's (version 1.18)
throughput while varying payload sizes and different worker counts.
Each worker is single threaded and uses one core.
The server is loaded with requests from a separate machine running
a load generater (\Code{bombardier}) with 100 concurrent
connections (chosen to maximize throughput) over a 1Gbps link.
The clients send http requests for files ranging between 20B and
10000B.

In \autoref{fig:midas:nginx_perf}, we plot the request rate and throughput
for Nginx servers running with one and eight workers.
For all configurations, we can see that the rate of requests served
remains almost constant while increasing payload size until the network
link reaches saturation.
Under a saturated network, the request rates for \midas match that
of the baseline system.
With a single worker, \midas' overheads cause a consistent~13--14\%
overhead on the request rate for small packet sizes.
However, we see that \midas has practically no overhead when serving
requests with 8 workers even when packet sizes are too small to
saturate the network link.
In this case, both \midas and the baseline system are limited by the
scalability of the Linux networking stack.

%%%%%%%%%%%%%%%%%%%%
\section{Related Work}
%%%%%%%%%%%%%%%%%%%%

Early work on double-fetch bugs relied primarily on manual
code analysis to identify bugs in kernel code~\cite{YangCSS12, twizsgrakky07ring0}
or in syscall wrappers~\cite{watson2007exploiting}.
Realizing the limited scalability of this approach, particularly
when applied to large codebases such as the Linux kernel, subsequent 
work focussed on automated techniques based on static or dynamic 
analysis techniques, and on leveraging hardware features to mitigate
such bugs.

% Realizing that large projects such as the Linux kernel are not 
% amenable to extensive man
% In this section, we describe the automated tools that followed,
% based on static or dynamic analysis techniques, which can be employed
% to find and mitigate \tocttou bugs.

\paragraph{Static analysis}
%
Static analysis proposals use code analysis to find and fix double fetch
vulnerabilities.
DFTinker~\cite{dftinker} improves the coverage of pattern matching rules
for detecting double fetches in code as initially proposed by Wang~et~al.~\cite{wang2017double}.
Deadline~\cite{deadline} and DFTracker~\cite{wang2019dftracker} further
generalize the analysis by leveraging symbolic execution.

However, static analysis is severely limited by its requirement for
source code, which eliminates possibility of protecting of analyzing
binary-only modules for which code is not available.
In contrast, \midas can also protect such modules since well-behaving
module use the kernel transfer functions to access user memory.
Symbolic execution solves the generality problem of pattern-matching
approaches but has its limitations (path explosion, function pointers,
modelling numerous library functions, etc.).
Deadline~\cite{deadline} specifically requires the additional assumption
that pointer syscall argument do not alias, an assumption that can
wilfully be violated by our adversarial model.

Additionally, the protection allowed by static analysis methods are
limited: only the bugs which are detected can be fixed, and static
analyses are necessarily incomplete.
In contrast, \midas mitigates \emph{all} \tocttou vulnerabilities.
Further, specific cases of double fetches, such as in syscall wrappers
cannot be fixed in code, and require a versioning system such as
\midas in order to enable deep argument inspection.

\paragraph{Dynamic Analysis}
%
Dynamic analysis techniques leverage runtime information and values
to detect double fetches, and are notable in their ability to
find bugs in binaries.

To enable the search for various classes of bugs, Google Project Zero's
Bochspwn project~\cite{jurczyk2013bochspwn} introduced
a comprehensive emulator for \Code{x86} with callbacks to allow
tracing of kernel operations, including memory accesses.
When paired with a syscall fuzzer,
Bochspwn successfully detected and reported double fetches from
these access logs, but suffered from a high rate of false positives.
Another major shortcoming of Bochspwn was its low execution throughput
of 40-80MIPS which limited its ability to explore code paths.
Xenpwn~\cite{wilhelm2016xenpwn} extended Bochspwn's trace-driven 
approach to fuzz hypervisors for double-fetch bugs.
Xenpwn found three double fetches in the Xen hypervisor, but no critical 
vulnerabilities in KVM.

DECAF~\cite{schwartzDECAF} inverts \midas' adversarial model, leveraging
concurrent access to syscall parameters from userspace to detect kernel
accesses via a cache side-channel.
DECAF is strongly reliant on CPU-specific behavior, which
is sensitive to CPU parameters, subject to changes from generation to
generation (or even from core to core) and prone to noise and false sharing.
Following the discovery of transient-execution attacks~\cite{KocherHFGGHHLM019},
proposals such as InvisiSpec~\cite{YanCS0FT19,KhasawnehKSEPA19} have
tried to prevent
information leakage via cache side-channels.
Future generations might entirely close this channel, or introduce constraints
that limits this information flow.

Dynamic analysis techniques can only detect vulnerabilities on executed code
paths, and therefore typically rely on a fuzzer to extensively cover kernel code.
However, fuzzers are inherently incomplete, limiting the ability of dynamic
analysis to find bugs.

% PeriScope\cite{SongH0SNVVKSF19} is out of scope.
% Devices are outside the scope of the current implementation of \midas. Particularly, double fetches from device backed memory is liable to change without any control, but already requires high privileges which the user does not have. DMA accesses to main memory, however, can be protected by the use of IOMMUs with very low overhead [4], and can take advantage of the same \midas mechanisms. [4] Border Control: Sandboxing Accelerators.
% Overall comment: \midas does not seek to overthrow methods that seek to find double fetches, and fix them. In fact, it also allows use as a sanitizer that flags such double fetches. In the meanwhile, however, bugs do persist and are likely to persist in an environment incorporating third-party code in modules and a rapid pace of development. Here, \midas provides a strong, principled guarantee which is also future-proof.

\paragraph{Mitigations}
%
Previous attempts~\cite{schwartzDECAF,dftinker} to eliminate double fetch
vulnerabilities rely on Intel TSX, a hardware transactional
memory implementation, to detect malicious writes to data read by the
kernel.
A defense based on TSX improves upon \midas by reducing the scope for
false sharing from a page size to a cache line size.
However, TSX suffers from major limitations which restrict its useability
for general kernel implementations.
Of note, TSX requires that the data working set for the critical section
experiences no L1 cache evictions, even due to contention from a
simultaneously-multithreaded (hyperthreading) core.
Further, TSX is deprecated and limited to processors from a specific 
manufacturer (Intel), leaving the vast majority
of computing devices~(mobile, IoT, AMD processors) unprotected.

%%%%%%%%%%%%%%%%%%%%
\section{\midas Summary}
%%%%%%%%%%%%%%%%%%%%

\midas mitigates double-fetch bugs in system calls and protects the operating
system interface by enforcing the invariant:  \emph{through a syscall's
lifetime, every read to a userspace object will return the same value}.
Our \midas implementation creates on-demand snapshots and copies of pages that
are read and merges any writes through the execution of the system call.
%
Our mitigation protects the core kernel, as well as drivers by carefully
instrumenting functions that interact with the process address space. While our
implementation focuses on Linux for x86-64, our concept is generic and empowers
other kernels to protect themselves against notoriously hard-to-find and
easy-to-exploit double fetch bugs.

The performance evaluation of our prototype implementation is promising.
Compute-bound benchmarks have negligible overhead and even syscall-intensive
benchmarks exhibit low overhead. On one hand, \midas mitigates all double fetch
bugs in the kernel and gives developers a tool to locate such bugs. On the other
hand, \midas sets the foundation for efficient, stateful system call filtering
and validation.
%
We have released the source code of our prototype as open-source at
\url{https://hexhive.epfl.ch/midas/}.